--{"gpuchip/":{"gpuchip/examples/":{"gpuchip/examples/sprite.txt":"// Author: Drunkie\n// Description: A very simple sprite example\n\nMain();\n\n#include <drivers\\drv_gl.txt>\n\nvoid Main()\n{\n    // Enable vertex mode\n    glVertexMode( 1 );\n\n    // Draw to sprite buffer\n    glSetRenderTarget( GL_BUFFER_BACK );\n    glClear( 0, 255, 0 );\n\n    // Draw to vertex buffer (world)\n    glSetRenderTarget( GL_BUFFER_VERTEX );\n    glEnable( GL_VERTEX_TEXTURING );\n\n    // Sample from sprite 0\n    glTextureSize( 256 );\n    glTexture( 0 );\n    glClear( 0, 255, 0 );\n    glRectWH( 128, 128, 256, 256 );\n\n    glSetRenderTarget( GL_BUFFER_FRONT );\n\n    glExit();\n}\n","gpuchip/examples/3d_icosahedron.txt":"// Author: Drunkie\n// Description: Draws a 3D icosahedron model (solid and wireframe)\n\nMain();\n\n#include <drivers\\drv_gl.txt>\n\nvoid Main()\n{\n    glSleep( 40 ); // Sleep for 40 milliseconds (Reduces fps lag)\n    glClear( 0, 0, 0 ); // Clear screen\n\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe to [-1 to 1] mode\n    glVertexPipe( GL_VPIPE_XYZTRANSFORM ); // Set vertex pipe to xyz transformation\n\n    glLightPos( 0, 0, -50 ); // Set the light position\n    glLightColor( 255, 255, 255, 1 ); // Set the light color\n\n    glLookAt(\n        0, 0, -2.25, // Camera pos\n        0, 0, 0, // Camera target\n        0, 1, 0 // Camera up\n    );\n\n    // Create variable to hold curtime\n    float time;\n    timer time;\n\n    // Create perspective and matrix transformations\n    glPerspective( 30, 1, 1, 20 ); // FOV, ASPECT RATIO, ZNEAR, ZFAR\n    glRotate( 1, 1, 0, time ); // AXIS X, Y, Z, ANGLE W\n    glTranslate( 0, 0, 0 ); // TRANSLATION X, Y, Z\n    glScale( 1, 1, 1, 0 ); // SCALE X, Y, Z\n\n    glEnable( GL_VERTEX_BUFFER ); // Enable vertex buffer\n    glEnable( GL_VERTEX_ZSORT ); // Enable Z sorting\n    glEnable( GL_VERTEX_LIGHTING ); // Enable vertex lighting\n    //glEnable( GL_VERTEX_CULLING ); // Enable face culling\n\n    // Solid 3D polygon\n    glFillMode( GL_FILL_SOLID ); // Set fillmode as solid\n    glColor4( 100, 149, 237, 180 ); // Set the draw color with alpha\n    glPoly3D( vertexBuffer, 20 ); // Draw 3D polygon\n    glFlush(); // Flush the vertex buffer to the screen\n\n    glDisable( GL_VERTEX_LIGHTING ); // Enable vertex lighting\n\n    // Wireframe 3D polygon\n    glLineWidth( 1 ); // Set line width of wireframe\n    glFillMode( GL_FILL_WIREFRAME ); // Set fillmode as wireframe\n    glColor4( 255, 255, 255, 255 ); // Set the draw color with alpha\n    glPoly3D( vertexBuffer, 20 ); // Draw 3D polygon\n    glFlush(); // Flush the vertex buffer to the screen\n\n    glExit(); // Exit\n}\n\n// The vertex data for our model\nvertexBuffer:\ndb 0,0,1; db 0,0.9,0.5; db 0.9,0.3,0.4;\ndb 0,0,1; db -0.9,0.3,0.4; db 0,0.9,0.5;\ndb 0,0,1; db -0.5,-0.7,0.4; db -0.9,0.3,0.4;\ndb 0,0,1; db 0.5,-0.7,0.4; db -0.5,-0.7,0.4;\ndb 0,0,1; db 0.9,0.3,0.4; db 0.5,-0.7,0.4;\ndb 0.9,-0.3,-0.4; db 0.9,0.3,0.4; db 0.5,0.7,-0.4;\ndb 0,0.9,0.5; db 0.5,0.7,-0.4; db 0.9,0.3,0.4;\ndb 0,0.9,0.5; db -0.5,0.7,-0.4; db 0.5,0.7,-0.4;\ndb 0,0.9,0.5; db -0.9,0.3,0.4; db -0.5,0.7,-0.4;\ndb -0.9,-0.3,-0.4; db -0.5,0.7,-0.4; db -0.9,0.3,0.4;\ndb -0.9,-0.3,-0.4; db -0.9,0.3,0.4; db -0.5,-0.7,0.4;\ndb -0.9,-0.3,-0.4; db -0.5,-0.7,0.4; db 0,-0.9,-0.5;\ndb 0.5,-0.7,0.4; db 0,-0.9,-0.5; db -0.5,-0.7,0.4;\ndb 0.5,-0.7,0.4; db 0.9,-0.3,-0.4; db 0,-0.9,-0.5;\ndb 0.5,-0.7,0.4; db 0.9,0.3,0.4; db 0.9,-0.3,-0.4;\ndb 0,0,-1; db 0,-0.9,-0.5; db 0.9,-0.3,-0.4;\ndb 0,0,-1; db 0.9,-0.3,-0.4; db 0.5,0.7,-0.4;\ndb 0,0,-1; db 0.5,0.7,-0.4 db -0.5,0.7,-0.4;\ndb 0,0,-1; db -0.5,0.7,-0.4; db -0.9,-0.3,-0.4;\ndb 0,0,-1; db -0.9,-0.3,-0.4; db 0,-0.9,-0.5;\n","gpuchip/examples/mt3.txt":"//== 3D Graphics begin here ====================================================\n  dvxpipe 3;\n  dcvxpipe 3;\n\n  //Calc depth here\n  mov #Background.MinDepth,  0.8; //Near distance\n  mov #Background.MaxDepth,  6.0; //Far distance\n  mov #Background.ShadeStart,1.0;\n  mov #Background.DepthStep ,0.3; //Depth step. The lower, the higher quality is\n\n  timer #Time; mul #Time,3;\n\n  mov EAX,#Time; mod EAX,#Background.DepthStep;\n\n  sub #Background.MinDepth,EAX;\n  sub #Background.MaxDepth,EAX;\n\n  //Initialize depth range\n  mov  #Background.deltaDepth,#Background.MaxDepth;\n  sub  #Background.deltaDepth,#Background.MinDepth;\n\n  //Compute background stuff\n  mov  #Background.ShadeStep,#Background.deltaDepth;\n  div  #Background.ShadeStep,#Background.DepthStep;\n  frnd #Background.ShadeStep;\n  finv #Background.ShadeStep;\n  mul  #Background.ShadeStep,#Background.ShadeStepMul;\n\n  //Brightness too\n  mov EAX,#Time; mod EAX,#Background.ShadeStep;\n  sub #Background.ShadeStart,EAX;\n\n  mov #_rect.color.r,200;\n  mov #_rect.color.b,200;\n\n// Uncomment this for trippy camera\n//  timer EAX; div EAX,8; fsin EBX,EAX; mul EBX,2;\n//  drotatescale EAX,EBX; mul EBX,2;\n\n  dsetwidth 0.8;\n  call Draw.Background;\ndexit;\n\nalloc Time;\n\n//==============================================================================\nDraw.Background:\n  //Draw all the rectangles\n  mov EAX,#Background.MinDepth; mov ECX,#Background.ShadeStart;\n  BackgroundLoop:\n    mov EDX,#Time; add EDX,EAX;\n    mov EBP,#Time; div EBP,6.28; fcos EBP,EBP;\n\n    fsin EDI,EDX; mul EDI,EBP; mul EDI,0.8; sub EDI,1;\n    mov #_rect.offset.x,EDI;\n\n    fcos ESI,EDX; mul ESI,EBP; mul ESI,0.4; sub ESI,1;\n    mov #_rect.offset.y,ESI;\n\n    mov EDX,ECX; fpwr EDX,2;\n    mov #regZOffset,EAX;\n\n    dcolor _rect.color;\n// Uncomment this for trippy HSL color\n//    mov ESI,#Time; add ESI,EAX;\n//    fsin #HSL.R,ESI; mul #HSL.R,127; add #HSL.R,128; add ESI,1.57;// mul EAX,2;\n//    fsin #HSL.G,ESI; mul #HSL.G,127; add #HSL.G,128; add ESI,1.57;// mul EAX,2;\n//    fsin #HSL.B,ESI; mul #HSL.B,127; add #HSL.B,128;\n//\n//    dcolor HSL;\n    dshade EDX;\n    dorectwh _rect.offset,_rect.wh;\n\n    sub ECX,#Background.ShadeStep;\n    add EAX,#Background.DepthStep;\n\n    cmp EAX,#Background.MaxDepth;\n    jl BackgroundLoop;\nret\n\n//==============================================================================\n//Drawing parameters\nscalar Background.MinDepth;\nscalar Background.MaxDepth;\nscalar Background.deltaDepth;\nscalar Background.DepthStep;\nscalar Background.ShadeStart;\nscalar Background.ShadeStep;\nscalar Background.ShadeStepMul,0.5;\n\ncolor HSL;\n\n//Generic rectangle\nvector2f _rect.offset,-1,-1;\nvector2f _rect.wh,2,2;\n\nvector2f _pad1.offset;\nvector2f _pad2.offset;\nvector2f _pad.wh;\n\n//Color scheme\ncolor _rect.color, 200,200,200;\ncolor _rect.color2,200,200,000;\n\ncolor _pad1.color, 000,200,000;\ncolor _pad2.color, 200,000,000;\n","gpuchip/examples/cube.txt":"//timer EAX;// div EAX,8;\n//fsin EAX,EAX;\n//mul EAX,512;\n//fabs EAX,EAX;\n//neg EAX;\n//add EAX,512;\n\ndcvxpipe 3; //-1..1 (opengl screen)\ndvxpipe  5; //matrix projection\n\n//Initialize transform\nmperspective mProjectionMatrix,vPerspective;\n\n//Render starts\ndclrscr  bg_color;\nmlookat mViewMatrix,vLookAt; //View matrix\n\ntimer eax;\nmov #vRotate.w,eax;\n\n//Rotate translate\nmrotate mRotateMatrix,vRotate;\nmtranslate mTranslateMatrix,vTranslate;\n\n//Create model matrix\nmmov mModelMatrix,mTranslateMatrix;\nmmul mModelMatrix,mRotateMatrix;\n\n//modelViewMatrix = ViewMatrix * modelMatrx\nmmov mModelViewMatrix,mViewMatrix;\nmmul mModelViewMatrix,mModelMatrix;\n\n//load matrix\nmload mModelViewMatrix;\nmloadproj mProjectionMatrix;\n\n//setup light\ndsetlight 0,lightdata;\n\n//setup buffer\ndenable 0; //Vertex buffer\ndenable 1; //ZSorting\ndenable 2; //Lighting\ndenable 3; //Face culling\n\n//render cube\ndcolor fg_color;\ndvxdata_3f cube2,12;\ndvxflush;\n\nddisable 0; //Disable everything!\nddisable 1;\nddisable 2;\nddisable 3;\n\ndcvxpipe 0;\ndvxpipe  0;\n\n//You can write some text here now\n//<right here>\ndexit;\n\n//========\ncube2:\ndb -1,-1,-1;\ndb 1,-1,-1;\ndb 1,1,-1;\ncube3:\ndb -1,-1,-1;\ndb 1,1,-1;\ndb -1,1,-1;\ncube4:\ndb 1,-1,1;\ndb -1,-1,1;\ndb 1,1,1;\ncube5:\ndb -1,-1,1;\ndb -1,1,1;\ndb 1,1,1;\ncube6:\ndb 1,-1,-1;\ndb -1,-1,-1;\ndb 1,-1,1;\ncube7:\ndb -1,-1,-1;\ndb -1,-1,1;\ndb 1,-1,1;\ncube8:\ndb -1,1,-1;\ndb 1,1,-1;\ndb 1,1,1;\ncube9:\ndb -1,1,1;\ndb -1,1,-1;\ndb 1,1,1;\ncube10:\ndb -1,-1,-1;\ndb -1,1,-1;\ndb -1,1,1;\ncube11:\ndb -1,-1,1;\ndb -1,-1,-1;\ndb -1,1,1;\ncube12:\ndb 1,1,-1;\ndb 1,-1,-1;\ndb 1,1,1;\ncube13:\ndb 1,-1,-1;\ndb 1,-1,1;\ndb 1,1,1;\n\nlightdata:\nvector4f lightpos,  0,50,-50,  0; //x y z <unused, will be falloff>\ncolor    lightcol,255,255,255,  1; //R G B Brightness\n//========\n\nmatrix mRotateMatrix;\nmatrix mTranslateMatrix;\n\nmatrix mProjectionMatrix;\t//This defines our projection to screen\nmatrix mViewMatrix;\t\t//This defines our camera transformations\n\nmatrix mModelMatrix;\t\t//This is our model transformations\nmatrix mModelViewMatrix;\t//This is our model relatively to camera transform\n\n\nvector4f vRotate,      1,  1,  1,  0; //<AXIS X Y Z> <ANGLE W>\nvector4f vTranslate,   0,  0,  0,  0; //<TRANLSATION X Y Z> <0>\nvector4f vPerspective, 30, 1.6,  1,  20; //<FOV> <ASPECT RATIO> <ZNEAR> <ZFAR>\n\nvLookAt:\nvector3f vLookAt_Eye,    0, 0, -5; //Where our camera is\nvector3f vLookAt_Center, 0, 0, 0;  //What we look at\nvector3f vLookAt_Up,     0, 1, 0;  //Where our matt-hat is\n\ncolor fg_color,255,255,25;\ncolor bg_color,64,32,12;\n","gpuchip/examples/verynice2.txt":"//Generated by WGUI tool. Get it at wiremod.com\n_page_0:\ndsetsize 16\ndcolor _c_0\ndrect _a_1,_a_2\ndcolor _c_1\ndrect _a_4,_a_5\ndcolor _c_2\ndrect _a_7,_a_8\ndcolor _c_3\ndrect _a_10,_a_11\ndcolor _c_3\ndrect _a_13,_a_14\ndcolor _c_2\nmov #_f_17,port0\ndwrite _a_16,_s_17\ndcolor _c_4\ndrect _a_19,_a_20\ndcolor _c_2\nmov #_f_23,port0\ndwrite _a_22,_s_23\ndcolor _c_4\ndwritefmt _a_25,_s_26\ndcolor _c_4\ndwritefmt _a_28,_s_29\ndcolor _c_4\ndwritefmt _a_31,_s_32\ndcolor _c_4\ndwritefmt _a_34,_s_35\ndcolor _c_4\ndwritefmt _a_37,_s_38\ndcolor _c_4\ndwritefmt _a_40,_s_41\ndcolor _c_4\ndwritefmt _a_43,_s_44\ndcolor _c_4\ndwritefmt _a_46,_s_47\ndcolor _c_3\ndrect _a_49,_a_50\ndcolor _c_2\nmov #_f_53,port0\ndwrite _a_52,_s_53\ndcolor _c_3\ndrect _a_55,_a_56\ndcolor _c_2\nmov #_f_59,port0\ndwrite _a_58,_s_59\ndcolor _c_2\ndwritefmt _a_61,_s_62\ndcolor _c_2\ndwritefmt _a_64,_s_65\ndcolor _c_2\ndwritefmt _a_67,_s_68\ndcolor _c_2\ndwritefmt _a_70,_s_71\ndcolor _c_2\ndwritefmt _a_73,_s_74\ndcolor _c_2\ndwritefmt _a_76,_s_77\ndexit\n\ncolor _c_0,0,0,160\nvec2f _a_1,8,8\nvec2f _a_2,504,504\ncolor _c_1,7,51,122\nvec2f _a_4,16,16\nvec2f _a_5,496,496\ncolor _c_2,0,0,0\nvec2f _a_7,24,24\nvec2f _a_8,488,488\ncolor _c_3,192,192,192\nvec2f _a_10,32,32\nvec2f _a_11,480,216\nvec2f _a_13,32,224\nvec2f _a_14,480,392\nvec2f _a_16,40,40\nstring _s_17,'VERYNICE GUI V2.1 Initialized...'\nalloc _f_17,0\ncolor _c_4,128,128,128\nvec2f _a_19,32,64\nvec2f _a_20,480,72\nvec2f _a_22,40,232\nstring _s_23,'Raw data feed:'\nalloc _f_23,0\nvec2f _a_25,88,256\nstring _s_26,'Input port 0: %f'\nvec2f _a_28,88,272\nstring _s_29,'Input port 1: %f'\nvec2f _a_31,88,288\nstring _s_32,'Input port 2: %f'\nvec2f _a_34,88,304\nstring _s_35,'Input port 3: %f'\nvec2f _a_37,88,320\nstring _s_38,'Input port 4: %f'\nvec2f _a_40,88,336\nstring _s_41,'Input port 5: %f'\nvec2f _a_43,88,352\nstring _s_44,'Input port 6: %f'\nvec2f _a_46,88,368\nstring _s_47,'Input port 7: %f'\nvec2f _a_49,32,400\nvec2f _a_50,248,480\nvec2f _a_52,40,408\nstring _s_53,'Vector feed 1:'\nalloc _f_53,0\nvec2f _a_55,264,400\nvec2f _a_56,480,480\nvec2f _a_58,272,408\nstring _s_59,'Vector feed 2:'\nalloc _f_59,0\nvec2f _a_61,40,424\nstring _s_62,'X: %f'\nvec2f _a_64,40,440\nstring _s_65,'Y: %f'\nvec2f _a_67,40,456\nstring _s_68,'Z: %f'\nvec2f _a_70,272,424\nstring _s_71,'X: %f'\nvec2f _a_73,272,440\nstring _s_74,'Y: %f'\nvec2f _a_76,272,456\nstring _s_77,'Z: %f'\n","gpuchip/examples/verynice1.txt":"dcolor c1;\ndrect p1,p2;\ndcolor c2;\ndrect p3,p4;\ndcolor c3;\ndrect p5,p6;\n\nmov #textpos1.y,80;\n\ndcolor c4;\ndsetsize 12;\ndwrite textpos1,text1;\n\nmov ecx,0;\nport_loop:\n  add #textpos1.y,18;\n  mov #textpos2.y,#textpos1.y;\n\n  mov #textpos2.x,#textpos1.x;\n  add #textpos2.x,90;\n  dwrite textpos1,text2;\n  dwritei textpos2,ecx;\n\n  in eax,ecx;\n\n  mov #textpos2.x,#textpos1.x;\n  add #textpos2.x,192;\n  dwritef textpos2,eax;\n\n  inc ecx;\n  cmp ecx,18;\n  jl port_loop;\n\ndexit;\n\nstring text1,'VERYNICE HUD SYSTEM INITIALIZED... VER 1.0';\nstring text2,'INPUT PORT        VALUE';\n\nvec2f textpos1,80,80;\nvec2f textpos2,80,80;\n\ncolor c1,0,0,255;\ncolor c2,0,0,127;\ncolor c3,0,0,64;\ncolor c4,255,255,255;\n\nvec2f p1,50,50;\nvec2f p2,450,450;\n\nvec2f p3,60,60;\nvec2f p4,430,430;\n\nvec2f p5,70,70;\nvec2f p6,440,440;\n","gpuchip/examples/trig.txt":"// Author: Jasongamer\n// Description: A tool for helping people learn trig\n\nMain();\n\n#include <drivers\\drv_gl.txt>\n\nvoid Main()\n{\n    glClear( 0, 0, 0 ); // Clear screen\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe (-1 to 1 mode)\n\n    timer R0; // Set time to curtime()\n    R0 = -R0 * 1;\n\n    glColor( 255, 255, 255 ); // Set draw color\n    glCircle( *orig.x, *orig.y, 0.66, 40 ); // Draw circle (x, y, radius, quality)\n\n    glColor( 0, 0, 0 );\n    glCircle( *orig.x, *orig.y, 0.64, 40 );\n\n    // Set the points for the trig\n    fcos *cos,R0;\n    fsin *sin,R0;\n\n    *PosR.x = *cos;\n    *PosR.x *= 0.65;\n    *PosR.x += *orig.x;\n\n    *PosR.y = *sin;\n    *PosR.y *= 0.65;\n    *PosR.y += *orig.y;\n\n    *PosX.x = *PosR.x;\n\n    glLineWidth( 0.01 ); // Set line width\n    glFontSize( 24 ); // Set font size\n\n    // X part of triangle\n    glColor( 0, 0, 255 );\n    glLine( *orig.x, *orig.y, *PosX.x, *PosX.y ); // Draw line\n    glWriteFmt( -0.95, -0.95, sCos ) // Write formatted string\n\n    // Y part of triangle\n    glColor( 255, 0, 0 );\n    glLine( *PosR.x, *PosR.y, *PosX.x, *PosX.y );\n    *sin *= -1; // Negate\n    glWriteFmt( -0.95, -0.85, sSin );\n\n    glColor( 255, 255, 255 );\n    glLine( *orig.x, *orig.y, *PosR.x, *PosR.y ); // Draw line\n\n    glExit(); // Exit\n}\n\nvec2f orig,0,0;\nvec2f PosR,0,0;\nvec2f PosX,0,0;\n\nstring sCos,\"Cosine = %f\";\nalloc cos;\n\nstring sSin,\"Sine   = %f\";\nalloc sin;\n","gpuchip/examples/texture.txt":"// Author: Drunkie\n// Description: A very simple texture example\n\nMain();\n\n#include <drivers\\drv_gl.txt>\n\nvoid Main()\n{\n    glVertexMode( 1 );\n    glColor( 255, 255, 255, 255 );\n\n    glBindTexture( 'brick/brick_model' );\n    glColor( 255, 255, 255, 255 );\n    glRectWH( 128, 128, 256, 256 );\n\n    glExit();\n}\n\n// ZASM version\n\n//mov #regVertexMode,1;\n//dcolor white;\n//dxtexture tex;\n//drectwh pos,size;\n//dexit;\n//color white,255,255,255;\n//string tex,'brick/brick_model';\n//vec2f pos,128,128;\n//vec2f size,256,256;\n","gpuchip/examples/terrain.txt":"// Matrix code is based on cube example\nDCPIPE 3 // -1 to 1 coordinate range, required by DDTERRAIN\nDVXPIPE 5 // XYZ projection + matrix\n\nDENABLE 0 // Vertex buffer\nDENABLE 1 // Z sorting\nDENABLE 2 // Lighting\nDENABLE 3 // Backface culling\n\nDSETLIGHT 0, Light\n\nMPERSPECTIVE ProjectionMatrix, Perspective\n\n// Rotate the terrain\nTIMER EAX\nDIV EAX, 4\nMOV #RotateVector.w, EAX\nMROTATE RotateMatrix, RotateVector\n\n// Point camera at terrain\nMLOOKAT ViewMatrix, LookAtArgs\nMMUL ViewMatrix, RotateMatrix\n\nMLOAD ViewMatrix\nMLOADPROJ ProjectionMatrix\n\nDCLRSCR Background\n\nDCOLOR Foreground\n//DXTEXTURE Texture // Doesn't work\nDDTERRAIN Terrain\n\nDVXFLUSH\n\nDEXIT\n\nCOLOR Foreground, 253, 186, 49, 255\nCOLOR Background, 1, 46, 87, 255\nCOLOR White, 255, 255, 255, 255\n\n//STRING Texture, \"brick/brick_model\";\n\n// The terrain struct\nTerrain:\n    DB 8, 8 // Terrain size\n    DB 16   // Draw distance, between 0 and 16\n    DB 0, 0 // Terrain offset\n\n    // 11 bytes unused\n    DB 0,0,0,0,0,0\n    DB 0,0,0,0,0\n\n    // 8 x 8 heightmap\n    DB  0.0,  0.3,  0.3,  0.3,  0.3,  0.0,  0.0,  0.0\n    DB  0.3,  0.3,  0.3,  0.5,  0.0, -0.5,  0.0,  0.0\n    DB  0.0,  1.5,  1.5,  1.0,  0.3, -0.5, -0.3,  0.0\n    DB  0.0,  1.0,  2.3,  1.8,  0.8,  0.3,  0.0,  0.0\n    DB  0.3,  0.8,  1.3,  2.3,  1.6,  0.8,  0.5,  0.0\n    DB  0.3,  0.5,  1.0,  1.3,  0.5,  0.3,  0.3,  0.0\n    DB  0.0,  0.3,  0.3,  0.3,  0.0, -0.3, -0.5,  0.0\n    DB  0.0,  0.0,  0.0,  0.0, -0.8, -0.8, -1.0, -0.5\n\nLight:\n    DB 0,   50, -50,  0   // Position\n    DB 255, 249, 225, 0.9 // RGB + Intensity\n\nMATRIX ProjectionMatrix\nMATRIX RotateMatrix\nMATRIX ViewMatrix\n\nVEC4F RotateVector, 0,  0,  1,  0  // Rotate around Z axis\nVEC4F Perspective,  50, 1,  1,  20 // 2nd value is aspect ratio\n\nLookAtArgs:\n    DB 0,  5,  4 // Camera\n    DB 0,  0,  0 // Look at\n    DB 0,  0, -1 // Up (terrain is upside-down for some reason)\n","gpuchip/examples/foxlogo.txt":"//Fox game console logo (also example on how to work with polygons)\n\ndclrscr chassis;\n\ndcolor fox1c;\ndvxdata_2f fox1a,16; //16 max!!\ndvxdata_2f fox2a,3;\ndvxdata_2f fox3a,3;\ndvxdata_2f fox4a,3;\ndvxdata_2f fox5a,3;\ndvxdata_2f fox6a,3;\ndvxdata_2f fox7a,6;\ndvxdata_2f fox8a,3;\n\ndcolor fox2c;\ndvxdata_2f fox2,4;\n\ndexit;\n\n//===========================================\ncolor chassis,0,0,0;\n\ncolor fox1c,60,60,60;\ncolor fox2c,100,100,100;\n//===========================================\nfox1a: //N=16\ndb 60,218\ndb 62,173\ndb 32,36\ndb 214,119\ndb 268,128\ndb 318,168\ndb 352,233\ndb 494,243\ndb 499,254\ndb 496,266\ndb 478,321\ndb 335,374\ndb 265,408\ndb 223,419\ndb 95,430\ndb 109,408\n\nfox2a: //N = 3\ndb 109,408\ndb 57,432\ndb 69,376\nfox3a:\ndb 69,376\ndb 33,394\ndb 59,327\nfox4a:\ndb 59,327\ndb 24,348\ndb 54,273\nfox5a:\ndb 54,273\ndb 29,286\ndb 57,240\nfox6a:\ndb 57,240\ndb 26,245\ndb 60,218\n\nfox7a: //N=6\ndb 109,408\ndb 69,376\ndb 59,327\ndb 54,273\ndb 57,240\ndb 60,218\n\nfox8a: //N=3\ndb 177,150;\ndb 269,150;\ndb 190,47;\n\n//===========================================\nfox2: //N=4\ndb 340,238\ndb 286,257\ndb 274,203\ndb 311,213\n//===========================================\n","gpuchip/examples/3d_letter_a.txt":"// Author: Drunkie\n// Description: Draws a 3D model of the letter A\n\nMain();\n\n#include <drivers\\drv_gl.txt>\n\nvoid Main()\n{\n    glSleep( 40 ); // Sleep for 40 milliseconds (reduces fps lag)\n    glClear( 100, 149, 237 ); // Clear screen\n\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe to [-1 to 1] mode\n    glVertexPipe( GL_VPIPE_XYZTRANSFORM ); // Set vertex pipe to xyz transformation\n\n    glLightPos( 0, 0, -50 ); // Set the light position\n    glLightColor( 255, 255, 255, 1 ); // Set the light color\n\n    glLookAt(\n        0, 0, -2.8, // Camera pos\n        0, 0, 0, // Camera target\n        0, 1, 0 // Camera up\n    );\n\n    // Create variable to hold curtime\n    float time;\n    timer time;\n\n    // Create perspective and matrix transformations\n    glPerspective( 30, 1, 1, 20 ); // FOV, ASPECT RATIO, ZNEAR, ZFAR\n    glRotate( 0, 1, 0, time ); // AXIS X, Y, Z, ANGLE W\n    glTranslate( 0, -0.1, 0, 0 ); // TRANSLATION X, Y, Z\n    glScale( 1, 1, 1, 0 ); // SCALE X, Y, Z\n\n    glEnable( GL_VERTEX_BUFFER ); // Enable vertex buffer\n    glEnable( GL_VERTEX_ZSORT ); // Enable Z sorting\n    glEnable( GL_VERTEX_LIGHTING ); // Enable vertex lighting\n    glEnable( GL_VERTEX_CULLING ); // Enable face culling\n\n    // Solid 3D polygon\n    glFillMode( GL_FILL_SOLID ); // Set fillmode as solid\n    glColor4( 255, 255, 255, 255 ); // Set draw color with alpha\n    glPoly3D( vertexBuffer, 30 ); // Draw 3D polygon\n    glFlush(); // Flush the vertex buffer to the screen\n\n    glExit(); // Exit\n}\n\n// The vertex data for our model\nvertexBuffer:\ndb 1,1,0; db 0.75,1,0; db 0.25,-1,0;\ndb 0.75,1,0; db 0,-1,0; db 0.25,-1,0;\ndb -1,1,0; db -0.25,-1,0; db -0.75,1,0;\ndb -0.75,1,0; db -0.25,-1,0; db 0,-1,0;\ndb 1,1,0.25; db 0.25,-1,0.25; db 0.75,1,0.25;\ndb 0.75,1,0.25; db 0.25,-1,0.25; db 0,-1,0.25;\ndb -1,1,0.25; db -0.75,1,0.25; db -0.25,-1,0.25;\ndb -0.75,1,0.25; db 0,-1,0.25; db -0.25,-1,0.25;\ndb 0.25,-1,0; db -0.25,-1,0; db 0.25,-1,0.25;\ndb -0.25,-1,0; db -0.25,-1,0.25; db 0.25,-1,0.25;\ndb -1,1,0; db -1,1,0.25; db -0.25,-1,0;\ndb -1,1,0.25; db -0.25,-1,0.25; db -0.25,-1,0;\ndb 1,1,0.25; db 1,1,0; db 0.25,-1,0;\ndb 1,1,0.25; db 0.25,-1,0; db 0.25,-1,0.25;\ndb -0.75,1,0; db 0,-1,0; db -0.75,1,0.25;\ndb -0.75,1,0.25; db 0,-1,0; db 0,-1,0.25;\ndb 0.75,1,0; db 0.75,1,0.25; db 0,-1,0;\ndb 0.75,1,0.25; db 0,-1,0.25; db 0,-1,0;\ndb -0.47,0.25,0; db -0.38,0.01,0; db 0.38,0.01,0;\ndb 0.38,0.01,0; db 0.47,0.25,0; db -0.47,0.25,0;\ndb -0.47,0.25,0.25; db 0.38,0.01,0.25; db -0.38,0.01,0.25;\ndb 0.38,0.01,0.25; db -0.47,0.25,0.25; db 0.47,0.25,0.25;\ndb -0.38,0.01,0; db -0.38,0.01,0.25; db 0.38,0.01,0;\ndb 0.38,0.01,0; db -0.38,0.01,0.25; db 0.38,0.01,0.25;\ndb -0.47,0.25,0; db 0.47,0.25,0; db -0.47,0.25,0.25;\ndb -0.47,0.25,0.25; db 0.47,0.25,0; db 0.47,0.25,0.25;\ndb -1,1,0; db -0.75,1,0; db -1,1,0.25;\ndb -0.75,1,0; db -0.75,1,0.25; db -1,1,0.25;\ndb 1,1,0; db 1,1,0.25; db 0.75,1,0;\ndb 0.75,1,0; db 1,1,0.25; db 0.75,1,0.25;\n","gpuchip/examples/3d_tunnel.txt":"// Author: Drunkie\n// Description: Draws a never ending tunnel in 3D!\n\nMain();\n\n#include <drivers\\drv_gl.txt>\n\nvoid Main()\n{\n    glSleep( 60 ); // Sleep for 60 milliseconds (reduces fps lag)\n    glClear( 0, 0, 0 ); // Clear screen\n\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe to [-1 to 1] mode\n    glVertexPipe( GL_VPIPE_XYZTRANSFORM ); // Set vertex pipe to xyz transformation\n\n    glLightPos( -1, -1, -1 ); // Set the light position\n    glLightColor( 255, 255, 255, 1.25 ); // Set the light color\n\n    glLookAt(\n        0, 0, -25, // Camera pos\n        0, 0, 0, // Camera target\n        0, 1, 0 // Camera up\n    );\n\n    // Loop and draw 4 models\n    for (i = 0; i < 4; i++)\n    {\n        // Set translations for each model\n        timer zTranslate;\n        zTranslate *= -16;\n        mod zTranslate,16;\n        zTranslate += (i * 16);\n\n        // Create perspective and matrix transformations\n        glPerspective( 8, 1, 0.4, 20 ); // FOV, ASPECT RATIO, ZNEAR, ZFAR\n        glRotate( 0, 0, 0, 0 ); // AXIS X, Y, Z, ANGLE W\n        glTranslate( 0, 0, zTranslate ); // TRANSLATION X, Y, Z\n        glScale( 1.2, 1, 8 ); // SCALE X, Y, Z\n\n        glEnable( GL_VERTEX_BUFFER ); // Enable vertex buffer\n        glEnable( GL_VERTEX_ZSORT ); // Enable Z sorting\n        glEnable( GL_VERTEX_LIGHTING ); // Enable vertex lighting\n        glEnable( GL_VERTEX_CULLING ); // Enable face culling\n\n        // Solid 3D polygon\n        glFillMode( GL_FILL_SOLID ); // Set fillmode as solid\n        glColor4( 255, 255, 255, 150 ); // Set the draw color with alpha\n        glPoly3D( VertexBuffer, 12 ); // Draw 3D polygon\n        glFlush(); // Send our vertex buffer to screen\n\n        // Wireframe 3D polygon\n        glLineWidth( 1 ); // Set line width of wireframe\n        glFillMode( GL_FILL_WIREFRAME ); // Set fillmode to wireframe\n        glColor4( 255, 255, 255, 255 ); // Set the draw color with alpha\n        glPoly3D( vertexBuffer, 8 ); // Draw 3D polygon\n        glFlush(); // Send our vertex buffer to screen\n    }\n\n    glExit(); // Exit\n}\n\nfloat i;\nfloat zTranslate;\n\nvertexBuffer:\ndb 1,1,-1; db -1,1,-1; db 1,1,1;\ndb -1,1,-1; db -1,1,1; db 1,1,1;\ndb 1,1,-1; db 1,1,1; db 1,-1,-1;\ndb 1,-1,-1; db 1,1,1; db 1,-1,1;\ndb -1,1,-1; db -1,-1,-1; db -1,1,1;\ndb -1,-1,-1; db -1,-1,1; db -1,1,1;\ndb 1,-1,-1; db 1,-1,1; db -1,-1,-1;\ndb -1,-1,-1; db 1,-1,1; db -1,-1,1;\n","gpuchip/examples/hud_engine.txt":"//mov #65522,1;\n//mov #65525,0.66;\n//port0 & port1 - engine left/right throttle (0..1)\n//port2 & port3 - delta (not used)\n\n//This displays engine window in PhoenixWings airplane\n\nmov #65485,16; //set circle quality\n\ndclrscr hud_border;\n\ndcolor hud_text;\ndcircle hud_engine1gauge,68;\ndcircle hud_engine2gauge,68;\ndcolor hud_border;\ndcircle hud_engine1gauge,64;\ndcircle hud_engine2gauge,64;\n\ndcolor hud_text;\ndsetwidth 1;\ndline hud_engine1gauge_start,hud_engine1gauge;\ndline hud_engine2gauge_start,hud_engine2gauge;\n\ndsetwidth 2;\n\n//===\nmov eax,port0; mul eax,100;\nmul eax,0.1;\nmul #left_power,1.9;\nadd #left_power,eax;\ndiv #left_power,2;\n\nmov eax,#left_power; div eax,100;\nmul eax,6.00;\nadd eax,1.57;\n\ndrotatescale eax,1;\ndmove hud_engine1gauge;\n\ndline gauge_base,gauge_needle;\n//==\nmov #right_power,#left_power; //comment this and..\n//uncomment if your left/right engines are not synchronized\n//mov eax,port1; mul eax,100;\n//mul eax,0.1;\n//mul #right_power,1.9;\n//add #right_power,eax;\n//div #right_power,2;\n\n//mov eax,#right_power; div eax,100;\n//mul eax,6.00;\n//add eax,1.57;\n\ndrotatescale eax,1;\ndmove hud_engine2gauge;\n\ndline gauge_base,gauge_needle;\n//==\n\n//use this for whatever you wanna\n//mov #left_delta,port2; sub #left_delta,7.6; mul #left_delta,10;\n//mov #right_delta,port3; sub #right_delta,7.6; mul #right_delta,10;\n\ndrotatescale 0,1; //reset!\ndmove 0;\n\ndsetfont 4;\ndsetsize 28;\ndwritefmt hud_text1pos,hud_text1;\ndwritefmt hud_text2pos,hud_text2;\n\ncmp port4,1;\ndcolor hud_yellow;\nje _nsh;\n  dshade 0.25;\n_nsh:\ndwrite hud_text3pos,hud_text3;\ndexit;\n\nvector2f hud_text1pos,70,212;\nvector2f hud_text2pos,310,212;\nvector2f hud_text3pos,20,460;\n\nstring hud_text1,'Left Engine',10,10,'N1 = %i%%',10,'Delta = %i%%';\nalloc left_power; alloc left_delta;\nstring hud_text2,'Right Engine',10,10,'N1 = %i%%',10,'Delta = %i%%';\nalloc right_power; alloc right_delta;\nstring hud_text3,'<FASTEN SEAT BELTS>';\n\nvector2f hud_engine1gauge,128,128;\nvector2f hud_engine1gauge_start,128,64;\n\nvector2f hud_engine2gauge,384,128;\nvector2f hud_engine2gauge_start,384,64;\n\nvector2f gauge_base,0,0;\nvector2f gauge_needle,0,-48;\n\ncolor hud_text,64,255,64;\ncolor hud_yellow,255,255,64;\ncolor hud_border,30,30,30;\n","gpuchip/examples/table.txt":"// Author: Drunkie\n// Description: Draws a table; useful for calendars or spreadsheets!\n\nMain();\n\n#include <drivers\\drv_gl.txt>\n\nfloat rows = 6;\nfloat cols = 5;\nfloat sizex = 476;\nfloat sizey = 400;\nfloat linewidth = 3;\n\nfloat i, j, day;\n\nvoid Main()\n{\n    dentrypoint 0,DrawThread;\n    dentrypoint 4,AsyncThread;\n\n    *regHWClear = 0\n    *regAsyncFreq = 200000;\n    *regAsyncClk = 1;\n}\n\nvoid DrawThread()\n{\n    dexit;\n}\n\nvoid AsyncThread()\n{\n    glBegin();\n\n        glClear( 35, 35, 35 ); // Clear screen color\n\n        glColor( 255, 255, 255 ); // Set draw color\n        glFont( GL_FONT_ARIAL ); // Set font type\n        glFontSize( 36 ); // Set font size\n        glWriteString( 16, 6, 'Simple-Calendar 1.0');\n\n        glColor( 120, 120, 120 );\n        glOffset( 16, 64 ); // Set screen offset\n        glRectWH( 0, 0, sizex + linewidth, sizey + linewidth); // Draw rectangle\n\n        glFont( GL_FONT_TREBUCHET );\n        glFontSize( 14 );\n\n        // Calculate rectangle size\n        float sx = (sizex / rows) - linewidth;\n        float sy = (sizey / cols) - linewidth;\n\n        // Loop through rows\n        for (i = 0; i < rows; i++)\n        {\n            // Loop through columns\n            for (j = 0; j < cols; j++)\n            {\n                // Calculate x,y coordinate to draw at\n                float x = i * (sizex / rows);\n                float y = j * (sizey / cols);\n\n                glColor( 200, 200, 200 ); // Set draw color\n                glRectWH( x + linewidth, y + linewidth, sx, sy ); // Draw rectangle\n\n                glColor( 0, 0, 0 ); // Set draw color\n\n                // Write integer to screen\n                day = i + (j * rows)\n                glWriteInt( x + linewidth + 2, y + linewidth + 2, day + 1 );\n            }\n        }\n\n    glEnd();\n}\n","gpuchip/examples/3d_cube.txt":"// Author: Drunkie\n// Description: 3D Cube\n\nMain();\n\n#include <drivers\\drv_gl.txt>\n\nvoid Main()\n{\n    glClear( 0, 0, 0 ); // Clear screen\n\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe to [-1 to 1] mode\n    glVertexPipe( GL_VPIPE_XYZTRANSFORM ); // Set vertex pipe to xyz transformation\n\n    glLightPos( 0, 0, -20 ); // Set the light position\n    glLightColor( 255, 255, 255, 1 ); // Set the light color\n\n    glLookAt(\n        0, 0, -5, // Camera pos\n        0, 0, 0, // Camera target\n        0, 1, 0 // Camera up\n    );\n\n    // Create variable to hold curtime\n    float time;\n    timer time;\n\n    // Create perspective and matrix transformations\n    glPerspective( 30, 1, 1, 20 ); // FOV, ASPECT RATIO, ZNEAR, ZFAR\n    glRotate( 1, 1, 0, time ); // AXIS X, Y, Z, ANGLE W\n    glTranslate( 0, 0, 0 ); // TRANSLATION X, Y, Z\n    glScale( 1, 1, 1 ); // SCALE X, Y, Z\n\n    glEnable( GL_VERTEX_BUFFER ); // Enable vertex buffer\n    glEnable( GL_VERTEX_ZSORT ); // Enable Z sorting\n\n    // Solid 3D polygon\n    glFillMode( GL_FILL_SOLID ); // Set fillmode as solid\n    glColor4( 100, 149, 237, 180 ); // Set draw color with alpha\n    glPoly3D( vertexBuffer, 12 ); // Draw 3D polygon\n    glFlush(); // Flush the vertex buffer to the screen\n\n    // Wireframe 3D polygon\n    glLineWidth( 1 ); // Set line width\n    glFillMode( GL_FILL_WIREFRAME ); // Set fillmode as solid\n    glColor4( 255, 255, 255, 255 ); // Set draw color with alpha\n    glPoly3D( vertexBuffer, 12 ); // Draw 3D polygon\n    glFlush(); // Flush the vertex buffer to the screen\n\n    glExit(); // Exit\n}\n\n// The vertex data for our model\nvertexBuffer:\ndb -1,-1,-1; db 1,-1,-1; db 1,1,-1;\ndb -1,-1,-1; db 1,1,-1; db -1,1,-1;\ndb 1,-1,1; db -1,-1,1; db 1,1,1;\ndb -1,-1,1; db -1,1,1; db 1,1,1;\ndb 1,-1,-1; db -1,-1,-1; db 1,-1,1;\ndb -1,-1,-1; db -1,-1,1; db 1,-1,1;\ndb -1,1,-1; db 1,1,-1; db 1,1,1;\ndb -1,1,1; db -1,1,-1; db 1,1,1;\ndb -1,-1,-1; db -1,1,-1; db -1,1,1;\ndb -1,-1,1; db -1,-1,-1; db -1,1,1;\ndb 1,1,-1; db 1,-1,-1; db 1,1,1;\ndb 1,-1,-1; db 1,-1,1; db 1,1,1;\n","gpuchip/examples/hud_fighter.txt":"//Aircraft hud\n//port0 - ROLL\n//port1 - PITCH\n//port2 - YAW (heading)\n//port3 - speed (units/sec)\n//port4 - altitude (units)\n//port5 - radar altitude (put ranger under your plane, and attach to this)\n//port6 - flaps active, 1 or 0\n//port7 - go to \"Gates - Time\", and find \"Derivative\". Attach this to derivative, and derivative to altitude (vertical speed)\n\n//Artiftical horizon\nin eax,0; //Roll\nin ebx,1; //Pitch\n\n//mul ebx,0.017453292;\nmul eax,0.017453292;\nadd eax,1.57;\n\ndiv ebx,90;\nmul ebx,512;\nadd ebx,256;\n\nmov #horizon_moveoffset.y,ebx;\n\ndrotatescale eax,1;\ndmove horizon_moveoffset;\n\ndcolor art_sky;\ndrectwh horizon_sky_offset,horizon_size;\ndcolor art_grnd;\ndrectwh horizon_grnd_offset,horizon_size;\n\ndcolor hud_text;\ndsetsize 20;\nmov eax,-45;\n_horizon_text:\n  mov ebx,eax;\n  mul ebx,5.68;\n  sub ebx,10;\n  mov #horizon_textpos1.y,ebx;\n  mov #horizon_textpos2.y,ebx; add ebx,9;\n  mov #horizon_rectpos1.y,ebx; add ebx,2;\n  mov #horizon_rectpos2.y,ebx;\n\n  drect horizon_rectpos1,horizon_rectpos2;\n  dwritei horizon_textpos1,eax;\n  dwritei horizon_textpos2,eax;\n\n  add eax,15;\n  cmp eax,45;\n  jle _horizon_text;\n\n//Reset\ndmove 0;\ndrotatescale 0,1;\n\n//Border around art horizon\ndcolor border_color;\ndrect border_p1,border_p2;\ndrect border_p3,border_p4;\ndrect border_p5,border_p6;\ndrect border_p7,border_p8;\ndcolor border_color2;\ndrect border_p9,border_p10;\n\n//Draw hud stuff\nmov #roll,port0;\nmov #pitch,port1;\nmov #hdg,port2; add #hdg,180;\nmov #spd,port3; div #spd,17.6;\nmov #alt,port4;\nadd #alt,12000;\ndiv #alt,12;\nmov #ralt,port5; div #ralt,12;\nmov #vspd,port7; div #vspd,17.6;\ndcolor hud_text;\ndwritefmt hud_pos1,hud_text1;\ndsetsize 16;\ndwritefmt hud_pos2,hud_text2;\n\ndcolor hud_text;\nmov eax,port6; mul eax,0.75; add eax,0.25;\ndshade eax;\ndwritefmt hud_pos3,hud_text3;\n\n\ndexit;\n\nvec2f hud_pos1,50,20;\nstring hud_text1,'ROLL %i %tPITCH %i%tHDG %i';\nalloc roll;\nalloc pitch;\nalloc hdg;\n\nvec2f hud_pos2,45,120;\nstring hud_text2,'SPD',10,'%ikt',10,10,'ALT',10,'%ift',10,10,'RALT',10,'%ift',10,10,'VSPD',10,'%ift/s';\nalloc spd;\nalloc alt;\nalloc ralt;\nalloc vspd;\n\nvec2f hud_pos3,45,400;\nstring hud_text3,'FLAPS';\n\n\nvec2f horizon_textpos1,96,0;\nvec2f horizon_textpos2,-64,0;\nvec2f horizon_rectpos1,-50,0;\nvec2f horizon_rectpos2,50,0;\ncolor hud_text,64,255,64;\n\ncolor border_color2,255,255,255;\ncolor border_color,30,30,30;\nvec2f border_p1,0,0;\nvec2f border_p2,128,512;\nvec2f border_p3,384,0;\nvec2f border_p4,512,512;\n\nvec2f border_p5,128,0;\nvec2f border_p6,384,64;\nvec2f border_p7,128,448;\nvec2f border_p8,384,512;\n\nvec2f border_p9,128,254;\nvec2f border_p10,384,258;\n\nvec2f horizon_sky_offset,-256,-512;\nvec2f horizon_grnd_offset,-256,0;\nvec2f horizon_size,512,512;\n\nvec2f horizon_moveoffset,256,256;\n\ncolor art_sky,24,144,255;\ncolor art_grnd,192,72,0;\n","gpuchip/examples/line_graph.txt":"// Author: Drunkie\n// Description: A fake lag-o-meter that plots points on a grid\n\nMain();\n\n#include <drivers\\drv_gl.txt>\n\nfloat i;\nfloat x, y;\nfloat ox = 0, oy = 256;\nfloat lines = 10;\nfloat lineWidth = 1\nfloat frameWidth = 510;\nfloat frameHeight = 300;\n\nvoid Main()\n{\n    glVertexMode( 1 ); // Enable vertex mode\n    glColor( 255, 255, 255 ); // Set draw color\n\n    // Set texture as background\n    glBindTexture( \"phoenix_storms/lag_sign\" );\n    glClearTexture();\n    glBindTexture( 0 ); // Discard texture\n\n    glFont( GL_FONT_AKBAR ); // Set font type\n    glFontSize( 36 ); // Set font size\n    glWriteString( 2, 2, \"LAG-O-METER\" ); // Write string to screen\n\n    glOffset( lineWidth, 90 ); // Offset the screen coordinates\n\n    glColor4( 0, 0, 0, 160 ); // Set draw color with alpha\n    glRectWH( 0, 0, frameWidth, frameHeight ); // Draw rectangle\n\n    glColor( 255, 255, 255 );\n    glLineWidth( lineWidth ); // Set line width\n    glORectWH( 0, 0, frameWidth, frameHeight ); // Draw outlined rectangle\n\n    glLineWidth( 1 ); // Set line width to 1\n\n    // Loop and make a bunch of connected lines\n    for (i = 0; i < lines; i++)\n    {\n        if (i == 0) {\n            ox = 0;\n            rand oy;\n            oy *= frameHeight;\n        }\n        else {\n            ox = x; oy = y;\n        }\n        x = ((i+1) / lines) * frameWidth;\n        rand y;\n        y *= frameHeight;\n        glLine( ox, oy, x, y ); // Draw line on graph\n    }\n\n    glOffset( 0, 0 ); // Set screen offset back to 0,0\n    glWriteString( 2, 400, \"INTENSE LAG DETECTED\" );\n\n    glExit(); // Exit\n}\n","gpuchip/examples/mt2.txt":"dcvxpipe 3;\nmov #regHWClear,0; //Stop hardware clearing\ndsetwidth 0.05;\n\ntimer EAX;\nmov EDX,EAX; sub EDX,#PrevTime; //EDX = Delta time\nmov #PrevTime,EAX;\n\nmov EBP,0.4; //Speed of rotation\n\nmov ECX,8;\nDrawLoop:\n  mov EAX,#Angle; mul EAX,1;\n  fsin #EndPoint.X,EAX; mul EAX,2;\n  fcos #EndPoint.Y,EAX;\n\n  //HSL coloring\n  fsin #HSL.R,EAX; mul #HSL.R,127; add #HSL.R,128; add EAX,1.57;// mul EAX,2;\n  fsin #HSL.G,EAX; mul #HSL.G,127; add #HSL.G,128; add EAX,1.57;// mul EAX,2;\n  fsin #HSL.B,EAX; mul #HSL.B,127; add #HSL.B,128;\n\n  dcolor HSL;\n\n  //Looks very nice\n  dline StartPoint1,EndPoint;\n  dline StartPoint2,EndPoint;\n  dline StartPoint3,EndPoint;\n  dline StartPoint4,EndPoint;\n\n  mul EDX,EBP;\n  add #Angle,EDX;\nloop DrawLoop;\n\ndexit;\n\nalloc Angle;\nalloc PrevTime;\n\ncolor HSL;\n\nvector2f EndPoint,0,0;\nvector2f StartPoint0,0,0;\nvector2f StartPoint1,1,1;\nvector2f StartPoint2,1,-1;\nvector2f StartPoint3,-1,-1;\nvector2f StartPoint4,-1,1;\n","gpuchip/examples/bounce.txt":"//////////////////////////////////\n//  BOUNCING BALL GPU EXAMPLE   //\n//////////////////////////////////\ndentrypoint 0,_draw;\t\t// Set draw start entrypoint to \"_draw\"\n\t\t\t\t//\nrand #ball.x;\t\t\t// Set random ball start point\nrand #ball.y;\t\t\t//\n\t\t\t\t//\ndexit;\t\t\t\t// Exit the initialization routine...\n//////////////////////////////////\n_draw:\t\t\t\t// Entrypoint for the drawing function\n\t\t\t\t//\ndcvxpipe 2;\t\t\t// Set coordinate pipe to 2 (to use coordinates 0...1)\ndclrscr bg_color;\t\t// Clear screen with background color\n\t\t\t\t//\ndmuldt eax,#d.x;\t\t// EAX = Direction Vector * Delta (change of coords per frame)\nadd #ball.x,eax;\t\t// Move the ball\ndmuldt eax,#d.y;\t\t//\nadd #ball.y,eax;\t\t//\n\t\t\t\t//\ncmp #ball.x,0.9;\t\t// Check hits against walls\ncge bounce.x;\t\t\t// Call bounce routine...\ncmp #ball.x,0.0;\t\t//\ncle bounce.x;\t\t\t//\n\t\t\t\t//\ncmp #ball.y,0.9;\t\t// Bounce on other axis\ncge bounce.y;\t\t\t//\ncmp #ball.y,0.0;\t\t//\ncle bounce.y;\t\t\t//\n\t\t\t\t//\ndcolor ball_color;\t\t// Set color to color of ball\ndrectwh ball,ball_wh;\t\t// Draw the ball\n\t\t\t\t//\ndsetsize 24;\t\t\t// Set font size\ndwrite textpos,text;\n\t\t\t\t//\ndexit;\t\t\t\t// Exit the draw function\n//////////////////////////////////\nbounce.x:\t\t\t// Bounce function (change X speed)\n  neg #d.x; \t\t\t//\n  min #ball.x,0.9;\t\t//\n  max #ball.x,0.0;\t\t//\nret\t\t\t\t//\n\t\t\t\t//\nbounce.y:\t\t\t// Bounce function (change Y speed)\n  neg #d.y;\t\t\t//\n  min #ball.y,0.9;\t\t//\n  max #ball.y,0.0;\t\t//\nret\t\t\t\t//\n//////////////////////////////////\n// Data and resources\t\t//\n//////////////////////////////////\n\t\t\t\t//\ncolor ball_color,255,255,255;\t// Ball color (white)\ncolor bg_color,   64, 32,128;\t// Background color (neon violet)\n\t\t\t\t//\nvector2f ball;\t\t\t// Ball position\nvector2f ball_wh,0.1,0.1;\t// Ball width/height\n\t\t\t\t//\nvector2f textpos,0.1,0.1;\t// Text position\n\t\t\t\t//\nvector2f d,1.0,1.0;\t\t// Movement direction & speed\n\t\t\t\t//\nstring text,'Bouncing ball!';\t// \"Bouncing ball!\"\n//////////////////////////////////\n","gpuchip/examples/plasma.txt":"//Plasma fractals\n//Converted by dlb from http://bocoup.com/processing-js/docs/index.php?page=Plasma%20Fractals\n//Which was converted by F1LT3R @ Hyper-Metrix.com from original at http://www.ic.sunysb.edu/Stu/jseyster/plasma/\n\nmov #regHWClear,0; //Stop GPU clearing itself\n\ndentrypoint 0,_draw; //Set the entry point for the draw loop\ndentrypoint 4,_async; //Set the enty point for the async loop\n\nmov #regAsyncFreq,2000000; //Make async run as fast as it can\nmov #regAsyncClk,1; //Start async\n\ndexit; //End init\n_draw: //Start draw\ndexit; //End draw\n\n//Setup variables\ncolor col;\nvec2f pos;\nvec2f size;\nfloat gridSize, edge1, edge2, edge3, edge4, midPoint, newWidth, newHeight, width, height, noise;\n\n_async: //Enter async\n\nmain(); //Run main function\n\nwhile(1){idle} //Infinatly loop\n\nvoid main(){ //Main function\n    dsetbuf_spr; //Use sprite buffer\n\n    setColor(255,255,255); //Set the colour to white\n    rect(0,0,512,512); //Draw a large rectangle\n\n    gridSize = 4; //How big each rectangle will be\n    width = 512; //GPU Width\n    height = 512; //GPU Height\n    noise = 5; //How noisy it will be\n\n    //Give initial corner values\n    R1 = random(1);\n    R2 = random(1);\n    R3 = random(1);\n    R4 = random(1);\n\n    plasma(0,0,width,height,R1,R2,R3,R4) //Start recursive function\n}\n\nvoid plasma(float x, y, width, height, c1, c2, c3, c4){ //Plasma function\n\n    //Setup local variables\n    float edge1, edge2, edge3, edge4, midPoint;\n\n    //Work out the size of the next segments\n    float newWidth = width / 2;\n    float newHeight = height / 2;\n\n    if((width > gridSize)||(height > gridSize)){ //If it is still bigger than the rectangle size\n\n        midPoint = (c1 + c2 + c3 + c4) / 4 + displace(newWidth + newHeight); //Randomly change the midpoint\n\n        //Calculate edges by averaging the corners\n        edge1 = (c1 + c2) / 2;\n        edge2 = (c2 + c3) / 2;\n        edge3 = (c3 + c4) / 2;\n        edge4 = (c4 + c1) / 2;\n\n        //Make sure it doesn't displace too far\n        max midPoint,0;\n        min midPoint,1;\n\n        //Run on the newly calculated segments\n        plasma(x, y, newWidth, newHeight, c1, edge1, midPoint, edge4);\n        plasma(x + newWidth, y, newWidth, newHeight, edge1, c2, edge2, midPoint);\n        plasma(x + newWidth, y + newHeight, newWidth, newHeight, midPoint, edge2, c3, edge3);\n        plasma(x, y + newHeight, newWidth, newHeight, edge4, midPoint, edge3, c4);\n    }else{ //Woo! It's the right size\n        float c = (c1 + c2 + c3 + c4) / 4; //Average the corners\n\n        float grey = c*255; //Multiply the corners by 255 to get a valid color\n\n        setColor(grey,grey,grey); //Set the color to your new color based on the \"height\"\n        rect(x,y,gridSize,gridSize); //Draw your rectangle\n    }\n}\n\nfloat displace(float num){ //Displace function, it just works\n    float m = num / (width + height) * (1/noise);\n    R1 = random(1);\n    return (R1-0.5) * m;\n}\n\nfloat random(float x){ //C version of the ASM rand opcode\n    preserve EAX;\n    rand EAX;\n    return EAX*x;\n}\n\nvoid setColor(float r,float g,float b){ //C version of the dcolor opcode\n    mov #col.r,r;\n    mov #col.g,g;\n    mov #col.b,b;\n\n    dcolor col;\n}\n\nvoid rect(float x, float y, float width, float height){ //C version of the drectwh opcode\n    mov #pos.x,x;\n    mov #pos.y,y;\n\n    mov #size.x,width;\n    mov #size.y,height;\n\n    drectwh pos, size;\n    dswap; //dswap to make it show since we're drawing to the sprite buffer\n}\n","gpuchip/examples/stargate.txt":"//STARGATE DIAL COMPUTER MAIN DISPLAY (realistic colors)\n//\n//How to connect:\n//GPU IOBus to Data Port\n//Port0 to \"Open\"\n//Port1 to \"Active\"\n//Port2 to \"Chevron\"\n//Port3 to \"Inbound\"\n//Port4 to iris\n//\n//That's all!\n\ndiv #65525,1.33;\nmov #65485,16; //65485 is the circle quality register\n\n//24 means circles have 24 sides\n//You can have up to 128 sides, but that LAGS\n//32 sides is not even noticable comparing to 128\n\n//= Misc decorations ==================\n\ndcolor stargate_out_ring;\ndcircle center,250;\ndcolor stargate_middle_ring;\ndcircle center,240;\ndcolor stargate_out_ring;\ndcircle center,223;\n\n//= Rotating ring =====================\nmov #65485,12;\ndcolor stargate_inner_ring;\n\nin ecx,2; //This block checks if chevron 7 is engaged\ncmp ecx,7; //If yes, dont spin\nmov eax,0;\njge _norotate;\n  timer eax;\n_norotate:\n\nin ebx,1; //This one checks if stargate is active\nmul eax,ebx;\n\nin ebx,3; neg ebx; add ebx,1; //This one checks if its inbound\nmul eax,ebx; //wormhole\n\ndrotatescale eax,1; //rotate by EAX radians\ndmove center;\ndcircle 0,220;\n\ndrotatescale 0,1; //Reset scale/movment\ndmove 0;\n\n//= Inner ring around EH ==============\nmov #65485,24;\ndcolor stargate_out_ring;\ndcircle center,190;\n\n\n//= EH ================================\ndcolor black;\ndcircle center,180; //draw black hole instead of event horizon\n\ndcolor stargate_eventhorizon;\n\nin ebx,0; //Stargate active?\ncmp ebx,0;\nmov eax,0;\nje _active;\n  rand eax;\n  mul eax,0.1;\n  add eax,0.9;\n_active:\n\nin ebx,0; mul ebx,180;\n\nmul #eventhorizon_radius,0.99;\nmul ebx,1.01;\nadd #eventhorizon_radius,ebx;\ndiv #eventhorizon_radius,2;\n\n\ndshade eax;\ndcircle center,#eventhorizon_radius;\n\n//= Iris ==============================\nmov edx,port4;\nneg edx; add edx,1;\n\nmov eax,#iris_status;\nsub eax,edx;\nfabs eax,eax;\n\ndmuldt ecx,8;\n\ncmp eax,0.02;\njl _donothing;\n  cmp #iris_status,edx;\n  jl _lower;\n    sub #iris_status,ecx;\n  jmp _donothing;\n  _lower:\n    add #iris_status,ecx;\n_donothing:\n\nmov #iris1.y,#iris_status;\nmul #iris1.y,#iris2.y;\n\ndmove center;\n\nmov ecx,12;\n_iris:\n  fsin ebx,ecx; fabs ebx,ebx; div ebx,10; add ebx,0.7;\n\n  mov eax,ecx; mul eax,0.490; add eax,0.01; //0.697\n  add eax,#iris_status;\n\n  drotatescale eax,1;\n\n  dcolor iris_color;\n  dshade ebx;\n\n  drect iris1,iris2;\nloop _iris;\n\ndmove 0;\n\n//= Chevrons ==========================\nmov eax,1; //Chevron ID\nin ebx,2;\ndmove center;\n_chevron_loop:\n  mov edx,eax; //Compute chevron angle in radians\n  mul edx,0.69815;\n  sub edx,1.23333;\n\n  drotatescale edx,1; //Rotate chevron polygon\n  dcolor stargate_chevron;\n\n  mov edx,eax:#chevron_triggers;\n\n  cmp edx,ebx; //Check if chevron is light up\n  jle _noshade;\n    dshade 0.25;\n  _noshade:\n\n  dvxpoly chevron_polygon,4; //draw chevron polygon\n\n  inc eax;\n  cmp eax,9;\n  jle _chevron_loop;\n\n//= Computer text =====================\ndrotatescale 0,1; //reset movement and scale\ndmove 0;\n\nin eax,3; //Is inbound?\ncmp eax,0;\nje _dexit;\n\n  timer eax; mul eax,2; fint eax; mod eax,2;\n  dcolor sgc_text;\n  dshade eax;\n\n  dsetsize 64; //draw message\n  dwrite sgc_inboundpos,sgc_inbound;\n\n_dexit:\ndexit;\n\n//= Helpers ===========================\n\nchevron_triggers:\ndb 9,4,5,6,7,1,2,3,8;\n// 1 2 3 4 5 6 7 8 9\n// Order in which chevrons light up\n// Only 1-7 are used though\n\n//=====================================\n\ncolor sgc_text,255,255,255;\n\nvector2f sgc_inboundpos,120,215;\nstring sgc_inbound,'INBOUND';\n\ncolor stargate_out_ring,    116,105, 76;\ncolor stargate_middle_ring, 93 , 85, 60;\ncolor stargate_inner_ring,  138,137,108;\ncolor stargate_eventhorizon, 93,114,162;\ncolor stargate_chevron,     250,162, 54;\ncolor iris_color,           192,192,192;\n\ncolor black,0,0,0;\n\nvector2f center,256,256;\n\nvector2f iris1,-44,0;\nvector2f iris2,44,175;\n\nvector2f chevcenter,-16,-256;\nvector2f chevsize,32,32;\n\nalloc eventhorizon_radius;\nalloc iris_status;\n\n//raw chevron poly data\n//format: <x> <y>\nchevron_polygon: //n=4\ndb -16,-251;\ndb 16,-251;\ndb 10,-230;\ndb -10,-230;\n"},"gpuchip/lib/":{"gpuchip/lib/drivers/":{"gpuchip/lib/drivers/drv_gl_toolkit.txt":"#ifndef GL\n#include <drivers\\drv_gl.txt>\n#endif\n\n#ifndef GLT\n\n#define GLT\n#define GLT_MAX_TRIANGLES 32\n\nfloat __GLT_VERTBUFF[(GLT_MAX_TRIANGLES * 3) * 3];\nfloat __GLT_VERTCNT = 0;\n\nvoid gltVertex(float x, float y, float z)\n{\n    if ((__GLT_VERTCNT / 3) >= GLT_MAX_TRIANGLES)\n        return;\n\n    float* ptr = __GLT_VERTBUFF;\n    ptr += (__GLT_VERTCNT * 3);\n\n    *ptr = x;\n    *(++ptr) = y;\n    *(++ptr) = z;\n\n    __GLT_VERTCNT++;\n}\n\nvoid gltTriangle(float x1, float y1, float z1,\n                 float x2, float y2, float z2,\n                 float x3, float y3, float z3)\n{\n    gltVertex(x1, y1, z1);\n    gltVertex(x2, y2, z2);\n    gltVertex(x3, y3, z3);\n}\n\nvoid gltQuad(float tlx, float tly, float tlz,\n             float trx, float try, float trz,\n             float brx, float bry, float brz,\n             float blx, float bly, float blz)\n{\n    gltTriangle(\n        trx, try, trz,\n        tlx, tly, tlz,\n        blx, bly, blz\n    );\n\n    gltTriangle(\n        brx, bry, brz,\n        trx, try, trz,\n        blx, bly, blz\n    );\n}\n\nvoid gltCube(float cex, float cey, float cez, float size)\n{\n    float s2 = size / 2;\n\n    gltQuad(\n        cex - s2, cey + s2, cez - s2,\n        cex + s2, cey + s2, cez - s2,\n        cex + s2, cey - s2, cez - s2,\n        cex - s2, cey - s2, cez - s2\n    );\n\n    gltQuad(\n        cex + s2, cey + s2, cez + s2,\n        cex - s2, cey + s2, cez + s2,\n        cex - s2, cey - s2, cez + s2,\n        cex + s2, cey - s2, cez + s2\n    );\n\n    gltQuad(\n        cex - s2, cey + s2, cez + s2,\n        cex - s2, cey + s2, cez - s2,\n        cex - s2, cey - s2, cez - s2,\n        cex - s2, cey - s2, cez + s2\n    );\n\n    gltQuad(\n        cex + s2, cey + s2, cez - s2,\n        cex + s2, cey + s2, cez + s2,\n        cex + s2, cey - s2, cez + s2,\n        cex + s2, cey - s2, cez - s2\n    );\n\n    gltQuad(\n        cex - s2, cey + s2, cez + s2,\n        cex + s2, cey + s2, cez + s2,\n        cex + s2, cey + s2, cez - s2,\n        cex - s2, cey + s2, cez - s2\n    );\n\n    gltQuad(\n        cex - s2, cey - s2, cez - s2,\n        cex + s2, cey - s2, cez - s2,\n        cex + s2, cey - s2, cez + s2,\n        cex - s2, cey - s2, cez + s2\n    );\n}\n\nvoid gltClearBuffer()\n{\n    __GLT_VERTCNT = 0;\n}\n\nvoid gltFlushBuffer()\n{\n    if (__GLT_VERTCNT <= 3)\n        return;\n\n    float vcnt = __GLT_VERTCNT;\n    float tcnt = (vcnt / 3) - (vcnt % 3);\n\n    if (tcnt > GLT_MAX_TRIANGLES)\n        tcnt = GLT_MAX_TRIANGLES;\n\n    glPoly3D(__GLT_VERTBUFF, tcnt);\n    glFlush();\n}\n\n#endif\n","gpuchip/lib/drivers/drv_gl.txt":"// [Author] - Drunkie\n// [Description] - A graphics driver that provides C-style functions for GPU\n// [Documentation] - http://goo.gl/DHhYb\n\n\n#define GL\n\n// Font\n#define GL_FONT_LUCIDA_CONSOLE 0\n#define GL_FONT_COURIER_NEW 1\n#define GL_FONT_TREBUCHET 2\n#define GL_FONT_ARIAL 3\n#define GL_FONT_TIMES_NEW_ROMAN 4\n#define GL_FONT_COOLVETICA 5\n#define GL_FONT_AKBAR 6\n#define GL_FONT_CSD 7\n\n// Buffer\n#define GL_BUFFER_FRONT 0\n#define GL_BUFFER_BACK 1\n#define GL_BUFFER_SPRITE 1\n#define GL_BUFFER_VERTEX 2\n\n// Coordinate pipe\n#define GL_CPIPE_DIRECT 0\n#define GL_CPIPE_RESOLUTION 1\n#define GL_CPIPE_0_1 2\n#define GL_CPIPE_N1_1 3\n#define GL_CPIPE_N256_256 4\n\n// Vertex pipe\n#define GL_VPIPE_XY 0\n#define GL_VPIPE_YZ 1\n#define GL_VPIPE_XZ 2\n#define GL_VPIPE_XYZPROJ 3\n#define GL_VPIPE_XYTRANSFORM 4\n#define GL_VPIPE_XYZTRANSFORM 5\n\n// denable / ddisable\n#define GL_VERTEX_BUFFER 0\n#define GL_VERTEX_ZSORT 1\n#define GL_VERTEX_LIGHTING 2\n#define GL_VERTEX_CULLING 3\n#define GL_VERTEX_DCULLING 4\n#define GL_VERTEX_TEXTURING 5\n\n// Fillmode\n#define GL_FILL_SOLID 0\n#define GL_FILL_WIREFRAME 1\n#define GL_FILL_TEXTURE 2\n\n// Cullmode\n#define GL_CULL_FRONT 0\n#define GL_CULL_BACK 1\n\n// Lightmode\n#define GL_LIGHT_FRONT 1\n#define GL_LIGHT_BACK -1\n\n// Horizontal font\n#define GL_ALIGN_LEFT 0\n#define GL_ALIGN_CENTER 1\n#define GL_ALIGN_RIGHT 2\n\n// Vertical font\n#define GL_VALIGN_TOP 0\n#define GL_VALIGN_MIDDLE 1\n#define GL_VALIGN_BOTTOM 2\n\n// Compatibility\n#define glSetTexture glBindTexture\n#define glWriteFmt glWriteFormat\n#define glFontHAlign glFontAlign\n\n\n// Clear\nvoid glClear( float r, float g, float b ) {\n    mov #GL_BG.r,r; mov #GL_BG.g,g; mov #GL_BG.b,b; mov #GL_BG.a,255;\n    dclrscr GL_BG;\n}\nvoid glClear4( float r, float g, float b, float a ) {\n    mov #GL_BG.r,r; mov #GL_BG.g,g; mov #GL_BG.b,b; mov #GL_BG.a,a;\n    dclrscr GL_BG;\n}\nvoid glClearTexture() {\n    dclrtex;\n}\nvoid glHWClear( float n ) {\n    mov #regHWClear,n;\n}\n\n// Color\nvoid glColor( float r, float g, float b ) {\n    mov #GL_FG.r,r; mov #GL_FG.g,g; mov #GL_FG.b,b; mov #GL_FG.a,255;\n    dcolor GL_FG;\n}\nvoid glColor4( float r, float g, float b, float a ) {\n    mov #GL_FG.r,r; mov #GL_FG.g,g; mov #GL_FG.b,b; mov #GL_FG.a,a;\n    dcolor GL_FG;\n}\nvoid glBrightness( float r, float g, float b, float a ) {\n    mov #regBrightnessR,r;\n    mov #regBrightnessG,g;\n    mov #regBrightnessB,b;\n    mov #regBrightnessW,a;\n}\nvoid glContrast( float r, float g, float b, float a ) {\n    mov #regContrastR,r;\n    mov #regContrastG,g;\n    mov #regContrastB,b;\n    mov #regContrastW,a;\n}\nvoid glShade( float n ) {\n    dshade n;\n}\nvoid glShadeNorm( float n ) {\n    dshadenorm n;\n}\n\n// Texture\nvoid glBindTexture( char* str ) {\n    dxtexture str;\n}\nvoid glTexture( float id ) {\n    dtexture id;\n}\nvoid glTextureSize( float n ) {\n    mov #regTexSize,n;\n}\nvoid glTextureDataPtr( float n ) {\n    mov #regTexDataPtr,n;\n}\nvoid glTextureDataSize( float n ) {\n    mov #regTexDataSz,n;\n}\nvoid glTextureRotation( float n ) {\n    mov #regTexRotation,n;\n}\nvoid glTextureScale( float n ) {\n    mov #regTexScale,n;\n}\nvoid glTextureCenterUV( float u, float v ) {\n    mov #regTexCenterU,u;\n    mov #regTexCenterV,v;\n}\nvoid glTextureOffsetUV( float u, float v ) {\n    mov #regTexOffsetU,u;\n    mov #regTexOffsetV,v;\n}\n\n// Frame\nvoid glSleep( float ms ) {\n    div ms,1000;\n    timer #GL_CURTIME;\n    sub #GL_CURTIME,#GL_TIMESTAMP;\n    if (*GL_CURTIME <= ms) {\n        mov #regHWClear,0;\n        dexit;\n    }\n    timer #GL_TIMESTAMP;\n}\nvoid glExit() {\n    dexit;\n}\n\n// Pipeline\nvoid glCoordPipe( float c ) {\n    dcpipe c;\n}\nvoid glVertexPipe( float v ) {\n    dvxpipe v;\n}\n\n// Hardware\nvoid glReset( float n ) {\n    mov #regReset,n;\n}\nvoid glHalt( float n ) {\n    mov #regHalt,n;\n}\nvoid glRAMReset( float n ) {\n    mov #regRAMReset,n;\n}\nvoid glHScale( float n ) {\n    mov #regHScale,n;\n}\nvoid glVScale( float n ) {\n    mov #regVScale,n;\n}\nvoid glHWScale( float n ) {\n    mov #regHWScale,n;\n}\nvoid glHWRotate( float n ) {\n    mov #regRotation,n;\n}\n\n// Offset\nvoid glOffset( float x, float y ) {\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\n    dmove GL_V1;\n}\nfloat glOffsetX() {\n    preserve eax;\n    mov eax,#regOffsetX;\n}\nfloat glOffsetY() {\n    preserve eax;\n    mov eax,#regOffsetY;\n}\nvoid glCenter( float x, float y ) {\n    mov #regCenterX,x;\n    mov #regCenterY,y;\n}\n\n// Async\nvoid glAsyncReset( float n ) {\n    mov #regAsyncReset,n;\n}\nvoid glAsyncClk( float n ) {\n    mov #regAsyncClk,n;\n}\nvoid glAsyncFreq( float n ) {\n    mov #regAsyncFreq,n;\n}\nvoid glEntryPoint( float idx, float ptr ) {\n    dentrypoint idx,ptr;\n}\nvoid glBegin() {\n    dbegin;\n}\nvoid glEnd() {\n    dend;\n}\nvoid glSwap() {\n    dswap;\n}\nvoid glSync() {\n    dvsync;\n}\n\n// Cursor\nvoid glCursor( float n ) {\n    mov #regCursor,n;\n}\nfloat glCursorX() {\n    preserve eax;\n    mov eax,#regCursorX;\n}\nfloat glCursorY() {\n    preserve eax;\n    mov eax,#regCursorY;\n}\n\n// Circle\nvoid glCircleQuality( float n ) {\n    mov #regCircleQuality,n;\n}\nvoid glCircleStart( float n ) {\n    mov #regCircleStart,n;\n}\nvoid glCircleEnd( float n ) {\n    mov #regCircleEnd,n;\n}\n\n// Screen scaling\nvoid glScreenScale( float n ) {\n    mov #regScale,n;\n}\nvoid glScreenScaleX( float x ) {\n    mov #regScaleX,x;\n}\nvoid glScreenScaleY( float y ) {\n    mov #regScaleY,y;\n}\n\n// 2D graphics\nvoid glCircle( float x, float y, float radius ) {\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\n    dcircle GL_V1,radius;\n}\nvoid glRect( float x, float y, float dx, float dy ) {\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\n    mov #GL_V2.x,dx; mov #GL_V2.y,dy;\n    drect GL_V1,GL_V2;\n}\nvoid glRectWH( float x, float y, float w, float h ) {\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\n    mov #GL_V2.x,w; mov #GL_V2.y,h;\n    drectwh GL_V1,GL_V2;\n}\nvoid glORect( float x, float y, float dx, float dy ) {\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\n    mov #GL_V2.x,dx; mov #GL_V2.y,dy;\n    dorect GL_V1,GL_V2;\n}\nvoid glORectWH( float x, float y, float w, float h ) {\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\n    mov #GL_V2.x,w; mov #GL_V2.y,h;\n    dorectwh GL_V1,GL_V2;\n}\nvoid glPixel( float x, float y ) {\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\n    dpixel GL_V1,GL_FG;\n}\nvoid glLine( float x, float y, float dx, float dy ) {\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\n    mov #GL_V2.x,dx; mov #GL_V2.y,dy;\n    dline GL_V1,GL_V2;\n}\nvoid glLineWidth( float w ) {\n    dsetwidth w;\n}\nvoid glPoly2D( float* buffer, float count ) {\n    dvxdata_2f buffer,count;\n}\n\n\n// Text\nvoid glFont( float id ) {\n    dsetfont id;\n}\nvoid glFontAlign( float n ) {\n    mov #regFontHalign,n;\n}\nvoid glFontVAlign( float n ) {\n    mov #regFontValign,n;\n}\nvoid glFontSize( float n ) {\n    dsetsize n;\n}\nfloat glTextWidth( char* str ) {\n    preserve eax;\n    dtextwidth eax,str;\n}\nfloat glTextHeight( char* str ) {\n    preserve eax;\n    dtextheight eax,str;\n}\nvoid glWriteString( float x, float y, char* str ) {\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\n    dwrite GL_V1,str;\n}\nvoid glWriteFloat( float x, float y, float n ) {\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\n    dwritef GL_V1,n;\n}\nvoid glWriteInt( float x, float y, float n ) {\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\n    dwritei GL_V1,n;\n}\nvoid glWriteFormat( float x, float y, char* str ) {\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\n    dwritefmt GL_V1,str;\n}\nfloat glParamList() {\n    preserve eax;\n    mov eax,#regParamList;\n}\n\n\n// 3D graphics\nvoid glPoly3D( float* buffer, float count ) {\n\n    if (*GL_MUPDATE == 1) {\n        mov #GL_MUPDATE,0;\n        mrotate GL_MROTATEMATRIX,GL_VROTATE;\n        mtranslate GL_MTRANSLATEMATRIX,GL_VTRANSLATE;\n        mscale GL_MSCALEMATRIX,GL_VSCALE;\n        mmov GL_MMODELMATRIX,GL_MTRANSLATEMATRIX;\n        mmul GL_MMODELMATRIX,GL_MROTATEMATRIX;\n        mmul GL_MMODELMATRIX,GL_MSCALEMATRIX;\n        mmov GL_MMODELVIEWMATRIX,GL_MVIEWMATRIX;\n        mmul GL_MMODELVIEWMATRIX,GL_MMODELMATRIX;\n        mload GL_MMODELVIEWMATRIX;\n        mloadproj GL_MPROJECTIONMATRIX;\n    }\n\n    if (*GL_FILLMODE == GL_FILL_SOLID) {\n        dvxdata_3f buffer,count;\n    }\n    else if (*GL_FILLMODE == GL_FILL_WIREFRAME) {\n        dvxdata_3f_wf buffer,count;\n    }\n    else if (*GL_FILLMODE == GL_FILL_TEXTURE) {\n        dvxdata_3f_tex buffer,count\n    }\n}\nvoid glFlush() {\n    dvxflush;\n}\nvoid glEnable( float n ) {\n    denable n;\n}\nvoid glDisable( float n ) {\n    ddisable n;\n}\nvoid glLightPos( float x, float y, float z ) {\n    mov #GL_LIGHTPOS.x,x; mov #GL_LIGHTPOS.y,y; mov #GL_LIGHTPOS.z,z;\n    dsetlight 0,GL_LIGHTDATA;\n}\nvoid glLightColor( float r, float g, float b, float a ) {\n    mov #GL_LIGHTCOL.r,r; mov #GL_LIGHTCOL.g,g;\n    mov #GL_LIGHTCOL.b,b; mov #GL_LIGHTCOL.a,a;\n    dsetlight 0,GL_LIGHTDATA;\n}\nvoid glFillMode( float n ) {\n    mov #GL_FILLMODE,n;\n}\nvoid glLookAt( float x, float y, float z, float tx, float ty, float tz, float ux, float uy, float uz ) {\n    mov #GL_VLOOKAT_POS.x,x; mov #GL_VLOOKAT_POS.y,y; mov #GL_VLOOKAT_POS.z,z;\n    mov #GL_VLOOKAT_TARG.x,tx; mov #GL_VLOOKAT_TARG.y,ty; mov #GL_VLOOKAT_TARG.z,tz;\n    mov #GL_VLOOKAT_UP.x,ux; mov #GL_VLOOKAT_UP.y,uy; mov #GL_VLOOKAT_UP.z,uz;\n    mlookat GL_MVIEWMATRIX,GL_VLOOKAT;\n    mov #GL_MUPDATE,1;\n}\nvoid glPerspective( float fov, float asp, float znear, float zfar ) {\n    mov #GL_VPERSPECTIVE.x,fov; mov #GL_VPERSPECTIVE.y,asp;\n    mov #GL_VPERSPECTIVE.z,znear; mov #GL_VPERSPECTIVE.w,zfar;\n    mperspective GL_MPROJECTIONMATRIX,GL_VPERSPECTIVE;\n    mov #GL_MUPDATE,1;\n}\nvoid glRotate( float x, float y, float z, float w ) {\n    mov #GL_VROTATE.x,x; mov #GL_VROTATE.y,y; mov #GL_VROTATE.z,z; mov #GL_VROTATE.w,w;\n    mov #GL_MUPDATE,1;\n}\nvoid glTranslate( float x, float y, float z ) {\n    mov #GL_VTRANSLATE.x,x; mov #GL_VTRANSLATE.y,y; mov #GL_VTRANSLATE.z,z;\n    mov #GL_MUPDATE,1;\n}\nvoid glScale( float x, float y, float z ) {\n    mov #GL_VSCALE.x,x; mov #GL_VSCALE.y,y; mov #GL_VSCALE.z,z;\n    mov #GL_MUPDATE,1;\n}\nvoid glZOffset( float n ) {\n    mov #regZOffset,n;\n}\nvoid glCullDistance( float n ) {\n    mov #regCullDistance,n;\n}\nvoid glCullMode( float n ) {\n    mov #regCullMode,n;\n}\nvoid glLightMode( float n ) {\n    mov #regLightMode,n;\n}\nvoid glVertexArray( float n ) {\n    mov #regVertexArray,n;\n}\n\n// Other\nvoid glVertexMode( float n ) {\n    mov #regVertexMode,n;\n}\nvoid glSetRenderTarget( float n ) {\n    if (n == GL_BUFFER_FRONT) {\n        dsetbuf_fbo;\n    }\n    else if (n == GL_BUFFER_BACK) {\n        dsetbuf_spr;\n    }\n    else if (n == GL_BUFFER_VERTEX) {\n        dsetbuf_vx;\n    }\n}\nfloat glIndex() {\n    preserve eax;\n    mov eax,#regIndex;\n}\n\n\n// Allocated variables for GL\ncolor GL_FG,255,255,255;\ncolor GL_BG;\nvec4f GL_V1;\nvec4f GL_V2;\n\nalloc GL_TIMESTAMP;\nalloc GL_CURTIME;\nalloc GL_FILLMODE;\n\nGL_LIGHTDATA:\nvec4f GL_LIGHTPOS,0,0,-10;\ncolor GL_LIGHTCOL,255,255,255,1;\n\nGL_VLOOKAT:\nvec3f GL_VLOOKAT_POS,0,0,-10;\nvec3f GL_VLOOKAT_TARG,0,0,0;\nvec3f GL_VLOOKAT_UP,0,1,0;\n\nmatrix GL_MROTATEMATRIX;\nmatrix GL_MTRANSLATEMATRIX;\nmatrix GL_MSCALEMATRIX;\nmatrix GL_MPROJECTIONMATRIX;\nmatrix GL_MVIEWMATRIX;\nmatrix GL_MMODELMATRIX;\nmatrix GL_MMODELVIEWMATRIX;\nalloc GL_MUPDATE,1;\n\nvec4f GL_VROTATE;\nvec4f GL_VTRANSLATE;\nvec4f GL_VPERSPECTIVE;\nvec4f GL_VSCALE,1,1,1,0;\n"}}},"spuchip/":{"spuchip/examples/":{"spuchip/examples/mario_theme.txt":"// Author: Jasongamer\n// Song: Mario Underwater Theme\n\n// Set track wave to channel 0 and start\nwset 0,trackwave;\nchwave 0,0;\nchvolume 0,0.2;\nchstart 0;\n\n// Set track wave to channel 1 and start\nwset 1,trackwave;\nchwave 1,1;\nchvolume 1,0.2;\nchstart 1;\n\n// Set bass wave to channel 2 and start\nwset 2,basswave;\nchwave 2,1;\nchvolume 2,0.3;\nchstart 2;\n\n// Get track length\ntracklen = strlen(trackA);\n\nvoid main()\n{\n    // Tempo\n    if ((i > 120) && (i <= 230))\n        tempo( 1000 );\n    else\n        tempo( 864 );\n\n    // Track A\n    note = 2;\n    fpwr note,(trackA[i]/12);\n    note /= 100;\n    chpitch 0,note;\n\n    // Track B\n    note = 2;\n    fpwr note,(trackB[i]/12);\n    note /= 100;\n    chpitch 1,note;\n\n    // Bass\n    note = 2;\n    fpwr note,(bass[i]/12);\n    note /= 100;\n    chpitch 2,note;\n\n    // Index\n    i++; mod i,tracklen;\n\n    // Repeat\n    jmp main;\n}\n\n// Accurate tempo function for beats-per-minute\nvoid tempo( float bpm )\n{\n    timer timestamp;\n    while ((time - timestamp) < (60 / bpm)) { timer time; }\n}\n\n// Returns the length of a string\nfloat strlen(char* str)\n{\n  char* strptr = str;\n  while (*strptr++);\n  return (strptr - str);\n}\n\nfloat note, i;\nfloat tracklen;\nfloat time, timestamp;\n\nstring trackwave,\"synth/square.wav\";\nstring basswave,\"synth/tri.wav\";\n\ntrackA:\n\n// Intro\ndb 73,73,73,73, 75,75,75,75, 77,77,77,77,   78,78,78,78, 80,80,80,80, 81,81,81,81;\ndb 82,-1,82,-1, 82,82,82,-1, 82,82,82,-1,   82,82,82,82, 82,82,82,-1, -1,-1,78,78;\n\n// Part 1\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   86,86,86,86, 86,86,86,86, 86,86,86,-1;\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   -1,-1,78,78, 80,80,82,82, 83,83,85,85;\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   86,86,86,86, 86,86,86,-1, 88,88,88,-1;\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,78,78;\ndb 85,85,85,85, 85,85,85,85, 85,85,85,-1,   84,84,84,84, 84,84,84,84, 84,84,84,-1;\ndb 85,85,85,85, 85,85,85,85, 85,85,85,-1,   -1,-1,78,78, 80,80,82,82, 83,83,84,84;\ndb 85,85,85,85, 85,85,85,85, 85,85,85,-1,   78,78,78,78, 78,78,78,-1, 88,88,88,-1;\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,78,78;\n\n// Part 2\ndb 90,90,90,90, 90,90,90,90, 90,90,90,-1,   90,90,90,90, 90,90,90,90, 90,90,90,-1;\ndb 90,90,90,90, 90,90,90,90, 90,90,90,-1,   90,90,90,-1, 92,92,-1,-1, -1,-1,90,90;\ndb 88,88,88,88, 88,88,88,88, 88,88,88,-1,   88,88,88,88, 88,88,88,88, 88,88,88,-1;\ndb 88,88,88,88, 88,88,88,88, 88,88,88,-1,   88,88,88,-1, 90,90,-1,-1, -1,-1,88,88;\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   80,80,80,-1, 82,82,82,-1, 88,88,88,-1;\ndb 87,-1,87,-1, 87,87,87,87, 87,-1,82,82,   83,83,83,83, 83,83,83,83, 83,83,83,-1;\n\ndb 0; // End string\n\ntrackB:\n\n// Intro\ndb 73,73,73,73, 72,72,72,72, 71,71,71,71,   70,70,70,70, 71,71,71,71, 72,72,72,72;\ndb 73,-1,73,-1, 73,73,73,-1, 75,75,75,-1,   76,76,76,76, 76,76,76,-1, -1,-1,-1,-1;\n\n// Part 1\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   77,77,77,77, 77,77,77,77, 77,77,77,-1;\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   77,77,77,77, 77,77,77,-1, 80,80,80,-1;\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\ndb 76,76,76,76, 76,76,76,76, 76,76,76,-1,   75,75,75,75, 75,75,75,75, 75,75,75,-1;\ndb 76,76,76,76, 76,76,76,76, 76,76,76,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\ndb 76,76,76,76, 76,76,76,76, 76,76,76,-1,   70,70,70,70, 70,70,70,-1, 80,80,80,-1;\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\n\n// Part 2\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   85,85,85,85, 85,85,85,85, 85,85,85,-1;\ndb 84,84,84,84, 84,84,84,84, 84,84,84,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\ndb 85,85,85,85, 85,85,85,85, 85,85,85,-1,   84,84,84,84, 84,84,84,84, 84,84,84,-1;\ndb 83,83,83,83, 83,83,83,83, 83,83,83,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\ndb 71,71,71,71, 71,71,71,71, 71,71,71,-1,   76,76,76,-1, 78,78,78,-1, 82,82,82,-1;\ndb 82,-1,82,-1, 82,82,82,-1, -1,-1,76,76,   75,75,75,75, 75,75,75,75, 75,75,75,-1;\n\ndb 0; // End string\n\nbass:\n\n// Intro\ndb -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\ndb -1,-1,-1,-1, -1,-1,-1,-1, 66,66,66,-1, 66,66,66,66, 66,66,66,66, 66,66,66,-1;\n\n// Part 1\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 58,58,58,-1, 66,66,66,-1, 70,70,70,-1;\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 63,63,63,-1, 66,66,66,-1, 71,71,71,-1;\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 58,58,58,-1, 66,66,66,-1, 70,70,70,-1;\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 63,63,63,-1, 66,66,66,-1, 71,71,71,-1;\ndb 61,61,61,-1, 66,66,66,-1, 70,70,70,-1, 60,60,60,-1, 65,65,65,-1, 69,69,69,-1;\ndb 61,61,61,-1, 66,66,66,-1, 70,70,70,-1, 58,58,58,-1, 66,66,66,-1, 70,70,70,-1;\ndb 61,61,61,-1, 66,66,66,-1, 70,70,70,-1, 58,58,58,-1, 66,66,66,-1, 70,70,70,-1;\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 54,54,54,-1, 66,66,66,-1, 71,71,71,-1;\n\n// Part 2\ndb 59,59,59,-1, 66,66,66,-1, 75,75,75,-1, 58,58,58,-1, 66,66,66,-1, 73,73,73,-1;\ndb 57,57,57,-1, 66,66,66,-1, 72,72,72,-1, 60,60,60,-1, 66,66,66,-1, 75,75,75,-1;\ndb 61,61,61,-1, 68,68,68,-1, 76,76,76,-1, 60,60,60,-1, 68,68,68,-1, 76,76,76,-1;\ndb 59,59,59,-1, 68,68,68,-1, 76,76,76,-1, 58,58,58,-1, 66,66,66,-1, 76,76,76,-1;\ndb 47,47,47,-1, 66,66,66,-1, 75,75,75,-1, 54,54,54,-1, 66,66,66,-1, 66,66,66,-1;\ndb 64,-1,64,-1, 64,64,64,-1, -1,-1,58,58, 59,59,59,59, 59,59,59,59, 59,59,59,-1;\n\ndb 0; // End string\n","spuchip/examples/beatbox.txt":"wset 4,inst1;\nchwave 1,4;\nchpitch 1,2.55;\n\nchwave 2,0;\nchvolume 2,0.5;\nchstart 2;\nchpitch 2,0;\n\nmainloop:\n  timer r0;\n  mul r0,6;\n  mov r1,r0;\n\n  fint r0;\n  mod r0,16;\n  add r0,0;\n  mod r1,1;\n  currentTick = r0;\n  currentTickTime = r1;\n\n  instr1 = patternData1[currentTick];\n  instr2 = patternData2[currentTick];\n  instr3 = patternData3[currentTick];\n\n  if ((pinstr1 == 0) && (instr1 == 1)) {\n    chstart 0;\n  } else {\n    chstop 0;\n  }\n\n  if ((pinstr2 == 0) && (instr2 == 1)) {\n    chstart 1;\n  } else {\n    chstop 1;\n  }\n\n  mov r0,currentTickTime; neg r0; add r0,1; fpwr r0,4;\n  mul r0,0.6; // add r0,0.64;\n  chpitch 0,r0;\n\n  mov r0,instr3;\n  mul r0,0.1;\n  add r0,0.2;\n  chpitch 2,r0;\njmp mainloop;\n\nfloat currentTick,currentTickTime;\nfloat instr1,instr2,instr3;\nfloat pinstr1,pinstr2;\n\npatternData1: db 1,1,0,0, 1,0,0,0, 1,0,0,1, 0,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,1, 1,0,1,0;\npatternData2: db 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0;\npatternData3: db 0,1,0,2, 0,1,2,2, 0,0,1,1, 1,2,1,2, 2,2,1,2, 2,2,1,1, 1,1,0,0, 0,0,1,2;\n\nstring inst1,\"synth/pink_noise.wav\";\n"}},"cpuchip/":{"cpuchip/examples/":{"cpuchip/examples/udh_test.txt":"//------------------------------------------------------------------------------\n// Universal Device Host driver test application\n//------------------------------------------------------------------------------\n#pragma CRT ZCRT\n\n//Include drivers for console screen and device host\n#include <drivers\\drv_udh.txt>\n#include <drivers\\drv_cscr.txt>\n\nvoid main() {\n  float i;\n  udhSetBusAddress(65536);\n\n  cscrInitialize(0);\n\n  udhQueryDevices();\n\n  for (i = 0; i < MAX_CONSOLE_SCREENS; i++) {\n    cscrSelect(i);\n    cscrSetActive(1);\n    cscrClear();\n\n    cscrSetCursor(0,0);\n    cscrPrintLine(\"Screen \",930);\n    cscrPrintNumber(i,930);\n  }\n\n  cscrSelect(0);\n  cscrSetCursor(0,2);\n  cscrPrintLine(\"UDH driver test\\n\",039);\n  for (i = 0; i < 8; i++) {\n    cscrPrintLine(\"DEVICE \",999);\n    cscrPrintNumber(i,999);\n    cscrPrintLine(\": \",999);\n    cscrPrintLine(udhGetDeviceName(i),666);\n    cscrPrintLine(\"\\n\",999);\n  }\n}\n","cpuchip/examples/helloworld.txt":"//Wired Hello World!\n//Connect CPU membus input to console screen\n//Connect CPUs CLK input to button (toggle)\n//Notice how you can store your\n//subroutines/calls in DATA area\njmp _code;\nmessage:\n  db 'Hello World!',0;\nWriteString: //ESI - String pointer, EDX - Param\n  mov eax,65536;\n  AWriteLoop:\n    cmp #esi,0; //Terminate on char 0\n    je AEnd;\n    mov #eax,#esi; //Output char\n    inc eax;\n    mov #eax,edx; //Output char param\n    inc eax;\n    inc esi;\n  jmp AWriteLoop;\n  AEnd:\nret //Return from call\n\n_code:\n  mov esi,message;\n  mov edx,000999; //White foreground on black background\n  call WriteString;\n\n//More about colors:\n//Lower 3 digits are foreground,\n//and higher 3 digits are background\n//Each of 3 digits shows amount of\n//RED, GREEN, and BLUE (in order)\n//Each color has 10 shades - from 0 to 9\n//\n//For example, 999044 will be dark yellow (044) on\n//a white background (999)\n//\n//Experiment with colors!\n//\n//Also, the 7th digit (if its not equal to 0) will\n//cause the character to blink by changing foreground and\n//background places (actual data in memory wont change)\n"},"cpuchip/lib/":{"cpuchip/lib/zcrt/":{"cpuchip/lib/zcrt/string.txt":"//------------------------------------------------------------------------------\n// ZCPU CRT sourcecode (for HL-ZASM compiler)         (C) 2011 by Black Phoenix\n//\n// String library. Contains functions to work with C strings (C89-compatible)\n//------------------------------------------------------------------------------\n\n#define NULL 0\n\n//copies n bytes between two memory areas; if there is overlap, the behavior is undefined\nvoid *memcpy(void *dest, void *src, float n) {\n  preserve esi,edi;\n  register float rem;\n\n  esi = src;\n  edi = dest;\n  rem = n;\n  while (rem) {\n    register float count = rem;\n    min count,8192;\n    mcopy count;\n    rem = rem - count;\n  }\n  return dest;\n}\n\n//copies n bytes between two memory areas; unlike with memcpy the areas may overlap\n//void *memmove(void *dest, void *src, float n);\n#define memmove memcpy\n\n//returns a pointer to the first occurrence of c in the first n bytes of s, or NULL if not found\nvoid* memchr(void *s, float c, float n) {\n  register void *r = s;\n  register float rem = n;\n\n  while (rem) {\n    if (*r == c) {\n      return r;\n    }\n    ++r;\n    --rem;\n  }\n\n  return NULL;\n}\n\n//compares the first n bytes of two memory areas\n//int memcmp(const void *s1, const void *s2, float n);\n#define memcmp strcmp\n\n//overwrites a memory area with n copies of c\nvoid* memset(void *ptr, float c, float n) {\n  register void *p = ptr;\n  register float rem = n;\n  register float ch = c;\n\n  while (rem) {\n    *p++ = ch;\n    --rem;\n  }\n\n  return ptr;\n}\n\n//appends the string src to dest\nchar* strcat(char *src, *dest) {\n  register char *srcptr, *destptr;\n\n  srcptr = src;\n  while (*++srcptr) ;\n\n  destptr = dest;\n  while (*srcptr++ = *destptr++) ;\n  return src;\n}\n\n//appends at most n bytes of the string src to dest\nchar* strncat(char *src, *dest, float n) {\n  register char *srcptr, *destptr;\n  register float i;\n\n  srcptr = src;\n  srcptr--;\n  while (*++srcptr) ;\n\n  destptr = dest;\n  i = n;\n  while (i--) {\n    if (*srcptr++ = *destptr++) continue;\n  }\n  *srcptr = 0;\n  return src;\n}\n\n//locates character c in a string, searching from the beginning\nchar* strchr(char *str, c) {\n  register char *strptr, ch;\n  strptr = str;\n  ch = c;\n  while(*strptr) {\n    if (*strptr == ch) return strptr;\n    ++strptr;\n  }\n  return 0;\n}\n\n//locates character c in a string, searching from the end\nchar* strrchr(char *str, c) {\n  register char *strptr, ch;\n  register char *findptr;\n\n  findptr = 0;\n  strptr = str;\n  ch = c;\n  while (*strptr) {\n    if (*strptr == ch) findptr = strptr;\n    ++strptr;\n  }\n  return findptr;\n}\n\n//compares two strings lexicographically\nfloat strcmp(char *src, *dest) {\n  register char *srcptr, *destptr;\n\n  srcptr = src;\n  destptr = dest;\n  while (*srcptr == *destptr) {\n    if (*srcptr == 0) return 0;\n    ++srcptr; ++destptr;\n  }\n  return (*srcptr - *destptr);\n}\n\n//compares up to the first n bytes of two strings lexicographically\nfloat strncmp(char *src, *dest, float n) {\n  register char *srcptr, *destptr;\n  register float i;\n\n  srcptr = src;\n  destptr = dest;\n  i = n;\n\n  while (i && (*srcptr == *destptr)) {\n    if (*srcptr == 0) return 0;\n    ++srcptr; ++destptr; --i;\n  }\n  if (i) return (*srcptr - *destptr);\n  return 0;\n}\n\n//copies a string from one location to another\nchar* strcpy(char *dest, *src) {\n  register char *srcptr, *destptr;\n\n  destptr = dest;\n  srcptr = src;\n  while (*destptr++ = *srcptr++) ;\n  return dest;\n}\n\n\n//write exactly n bytes to dest, copying from src or add 0's\nchar* strncpy(char *dest, *src, float n) {\n  register char *srcptr, *destptr;\n  register float i;\n\n  destptr = dest;\n  srcptr = src;\n  i = n;\n\n  while (i-- > 0) {\n    if (*destptr++ = *srcptr++) continue;\n    while (i-- > 0) *destptr++ = 0;\n  }\n  *destptr = 0;\n  return dest;\n}\n\n//returns the string representation of an error number e.g. errno\n//char *strerror(int);\n\n//finds the length of a C string\nfloat strlen(char* str) {\n  register char* strptr;\n  register float n;\n\n  strptr = str;\n  n = 0;\n  while (*strptr++) n++;\n  return n;\n}\n\n//determines the length of the maximal initial substring consisting entirely of characters in accept\nfloat strspn(char *str, *accept) {\n  register char *s = str;\n  register char *p = accept;\n\n  while (*p) {\n    if (*p++ == *s) {\n      ++s;\n      p = accept;\n    }\n  }\n  return s - str;\n}\n\n//determines the length of the maximal initial substring consisting entirely of characters not in reject\nfloat strcspn(char *str, char *reject) {\n  register char *s, *p;\n\n  for (s=str; *s; s++) {\n    for (p=reject; *p; p++) {\n      if (*p == *s) goto done;\n    }\n  }\n  done:\n  return s - str;\n}\n\n//finds the first occurrence of any character in accept\nchar* strpbrk(char *str, char *accept) {\n  register char *s;\n  register char *p;\n\n  for (s=str; *s; s++) {\n    for (p=accept; *p; p++) {\n      if (*p == *s) return s;\n    }\n  }\n  return NULL;\n}\n\n//finds the first occurrence of the string \"needle\" in the longer string \"haystack\"\nchar *strstr(char *haystack, char *needle) {\n  register char *s = haystack;\n  register char *p = needle;\n\n  while (1) {\n    if (!*p) {\n      return haystack;\n    }\n    if (*p == *s) {\n      ++p;\n      ++s;\n    } else {\n      p = needle;\n      if (!*s) {\n        return NULL;\n      }\n      s = ++haystack;\n    }\n  }\n}\n\n//parses a string into a sequence of tokens; non-thread safe in the spec, non-reentrant\n//char *strtok(char *, const char * delim);\n\n//transforms src into a collating form, such that the numerical sort order of the transformed string is equivalent to the collating order of src\n//float strxfrm(char *dest, const char *src, float n);\n","cpuchip/lib/zcrt/init.txt":"//------------------------------------------------------------------------------\n// ZCPU CRT sourcecode (for HL-ZASM compiler)         (C) 2011 by Black Phoenix\n//\n// C runtime library initialization\n//------------------------------------------------------------------------------\n\n#ifdef ZCRT_EXTENDED_MODE\n  // Initialize extended mode\n  mov edi,&zcrtInterruptTable; //Need \"&\" because array is defined below\n  mov esi,&zcrtInterruptTable; add esi,1024;\n  @InitTable:\n    mov #edi,zcrtErrorHandler; inc edi;\n    mov #edi,0;                inc edi;\n    mov #edi,0;                inc edi;\n    mov #edi,32;               inc edi;\n    cmp edi,esi;\n    jl @InitTable;\n\n  lidtr zcrtInterruptTable;\n  stef;\n#endif\n\n// Call main function\nmain();\n\n// Stop the processor execution\n#ifdef ZCRT_EXTENDED_MODE\n  clef;\n#endif\nint 1;\n\n//------------------------------------------------------------------------------\n// Allocate the interrupt table\n#ifdef ZCRT_EXTENDED_MODE\n  float zcrtInterruptTable[1024];\n  char* zcrtInterruptEntrypoint;\n\n  // Default interrupt handlers\n  zcrtErrorHandler:\n    //Execute handler if required\n    if (zcrtInterruptEntrypoint) {\n      float errorNo,errorCode;\n      cpuget errorNo,28;\n      cpuget errorCode,27;\n\n      zcrtInterruptEntrypoint(errorNo,errorCode);\n    }\n  iret\n#endif\n","cpuchip/lib/zcrt/ctype.txt":"//------------------------------------------------------------------------------\n// ZCPU CRT sourcecode (for HL-ZASM compiler)         (C) 2011 by Black Phoenix\n//\n// Character classification functions.\n//------------------------------------------------------------------------------\n\n#define _CONTROL 1\n#define _SPACE   2\n#define _BLANK   4\n#define _DIGIT   8\n#define _HEX     16\n#define _PUNCT   32\n#define _UPPER   64\n#define _LOWER   128\n#define _GRAPH   256\n\n#define _MAXCHARS 0x83\n\n//test for alphanumeric character\nfloat isalnum(char c) {\n  preserve eax;\n  eax = c; max eax,0; min eax,_MAXCHARS;\n  eax = __ctype_characters[eax];\n\n  band eax,_LOWER+_UPPER+_DIGIT;\n}\n\n//test for alphabetic character\nfloat isalpha(char c) {\n  preserve eax;\n  eax = c; max eax,0; min eax,_MAXCHARS;\n  eax = __ctype_characters[eax];\n\n  band eax,_LOWER+_UPPER;\n}\n\n//test for blank character\nfloat isblank(char c) {\n  preserve eax;\n  eax = c; max eax,0; min eax,_MAXCHARS;\n  eax = __ctype_characters[eax];\n\n  band eax,_BLANK;\n}\n\n//test for control character\nfloat iscontrol(char c) {\n  preserve eax;\n  eax = c; max eax,0; min eax,_MAXCHARS;\n  eax = __ctype_characters[eax];\n\n  band eax,_CONTROL;\n}\n\n//test for digit\nfloat isdigit(char c) {\n  preserve eax;\n  eax = c; max eax,0; min eax,_MAXCHARS;\n  eax = __ctype_characters[eax];\n\n  band eax,_DIGIT;\n}\n\n//test for graphic character, excluding the space character\nfloat isgraph(char c) {\n  preserve eax;\n  eax = c; max eax,0; min eax,_MAXCHARS;\n  eax = __ctype_characters[eax];\n\n  band eax,_GRAPH;\n}\n\n//test for lowercase character\nfloat islower(char c) {\n  preserve eax;\n  eax = c; max eax,0; min eax,_MAXCHARS;\n  eax = __ctype_characters[eax];\n\n  band eax,_LOWER;\n}\n\n//test for printable character, including the space character.\nfloat isprint(char c) {\n  preserve eax;\n  eax = c; max eax,0; min eax,_MAXCHARS;\n  eax = __ctype_characters[eax];\n\n  band eax,_LOWER+_UPPER+_DIGIT+_PUNCT+_BLANK+_GRAPH;\n}\n\n//test for punctuation character\nfloat ispunct(char c) {\n  preserve eax;\n  eax = c; max eax,0; min eax,_MAXCHARS;\n  eax = __ctype_characters[eax];\n\n  band eax,_PUNCT;\n}\n\n//test for any whitespace character\nfloat isspace(char c) {\n  preserve eax;\n  eax = c; max eax,0; min eax,_MAXCHARS;\n  eax = __ctype_characters[eax];\n\n  band eax,_SPACE;\n}\n\n//test for uppercase character\nfloat isupper(char c) {\n  preserve eax;\n  eax = c; max eax,0; min eax,_MAXCHARS;\n  eax = __ctype_characters[eax];\n\n  band eax,_UPPER;\n}\n\n//test for hexadecimal digit. Not locale-specific.\nfloat isxdigit(char c) {\n  preserve eax;\n  eax = c; max eax,0; min eax,_MAXCHARS;\n  eax = __ctype_characters[eax];\n\n  band eax,_HEX;\n}\n\n//convert character to lowercase\nchar tolower(char c) {\n  if (islower(c)) return c - 0x20;\n  return c;\n}\n\n//convert character to uppercase\nchar toupper(char c) {\n  if (isupper(c)) return c + 0x20;\n  return c;\n}\n\n__ctype_characters:\n  db _CONTROL,        //00 (NUL)\n  db _CONTROL;        //01 (SOH)\n  db _CONTROL;        //02 (STX)\n  db _CONTROL;        //03 (ETX)\n  db _CONTROL;        //04 (EOT)\n  db _CONTROL;        //05 (ENQ)\n  db _CONTROL;        //06 (ACK)\n  db _CONTROL;        //07 (BEL)\n  db _CONTROL;        //08 (BS)\n  db _SPACE+_CONTROL; //09 (HT)\n  db _SPACE+_CONTROL; //0A (LF)\n  db _SPACE+_CONTROL; //0B (VT)\n  db _SPACE+_CONTROL; //0C (FF)\n  db _SPACE+_CONTROL; //0D (CR)\n  db _CONTROL;        //0E (SI)\n  db _CONTROL;        //0F (SO)\n  db _CONTROL;        //10 (DLE)\n  db _CONTROL;        //11 (DC1)\n  db _CONTROL;        //12 (DC2)\n  db _CONTROL;        //13 (DC3)\n  db _CONTROL;        //14 (DC4)\n  db _CONTROL;        //15 (NAK)\n  db _CONTROL;        //16 (SYN)\n  db _CONTROL;        //17 (ETB)\n  db _CONTROL;        //18 (CAN)\n  db _CONTROL;        //19 (EM)\n  db _CONTROL;        //1A (SUB)\n  db _CONTROL;        //1B (ESC)\n  db _CONTROL;        //1C (FS)\n  db _CONTROL;        //1D (GS)\n  db _CONTROL;        //1E (RS)\n  db _CONTROL;        //1F (US)\n  db _SPACE+_BLANK;   //20 SPACE\n  db _PUNCT;          //21 !\n  db _PUNCT;          //22 \"\n  db _PUNCT;          //23 #\n  db _PUNCT;          //24 $\n  db _PUNCT;          //25 %\n  db _PUNCT;          //26 &\n  db _PUNCT;          //27 '\n  db _PUNCT;          //28 (\n  db _PUNCT;          //29 )\n  db _PUNCT;          //2A *\n  db _PUNCT;          //2B +\n  db _PUNCT;          //2C ;\n  db _PUNCT;          //2D -\n  db _PUNCT;          //2E .\n  db _PUNCT;          //2F /\n  db _DIGIT+_HEX;     //30 0\n  db _DIGIT+_HEX;     //31 1\n  db _DIGIT+_HEX;     //32 2\n  db _DIGIT+_HEX;     //33 3\n  db _DIGIT+_HEX;     //34 4\n  db _DIGIT+_HEX;     //35 5\n  db _DIGIT+_HEX;     //36 6\n  db _DIGIT+_HEX;     //37 7\n  db _DIGIT+_HEX;     //38 8\n  db _DIGIT+_HEX;     //39 9\n  db _PUNCT;          //3A :\n  db _PUNCT;          //3B ;\n  db _PUNCT;          //3C <\n  db _PUNCT;          //3D =\n  db _PUNCT;          //3E >\n  db _PUNCT;          //3F ?\n  db _PUNCT;          //40 @\n  db _UPPER+_HEX;     //41 A\n  db _UPPER+_HEX;     //42 B\n  db _UPPER+_HEX;     //43 C\n  db _UPPER+_HEX;     //44 D\n  db _UPPER+_HEX;     //45 E\n  db _UPPER+_HEX;     //46 F\n  db _UPPER;          //47 G\n  db _UPPER;          //48 H\n  db _UPPER;          //49 I\n  db _UPPER;          //4A J\n  db _UPPER;          //4B K\n  db _UPPER;          //4C L\n  db _UPPER;          //4D M\n  db _UPPER;          //4E N\n  db _UPPER;          //4F O\n  db _UPPER;          //50 P\n  db _UPPER;          //51 Q\n  db _UPPER;          //52 R\n  db _UPPER;          //53 S\n  db _UPPER;          //54 T\n  db _UPPER;          //55 U\n  db _UPPER;          //56 V\n  db _UPPER;          //57 W\n  db _UPPER;          //58 X\n  db _UPPER;          //59 Y\n  db _UPPER;          //5A Z\n  db _PUNCT;          //5B [\n  db _PUNCT;          //5C \\\n  db _PUNCT;          //5D ]\n  db _PUNCT;          //5E ^\n  db _PUNCT;          //5F _\n  db _PUNCT;          //60 `\n  db _LOWER+_HEX;     //61 a\n  db _LOWER+_HEX;     //62 b\n  db _LOWER+_HEX;     //63 c\n  db _LOWER+_HEX;     //64 d\n  db _LOWER+_HEX;     //65 e\n  db _LOWER+_HEX;     //66 f\n  db _LOWER;          //67 g\n  db _LOWER;          //68 h\n  db _LOWER;          //69 i\n  db _LOWER;          //6A j\n  db _LOWER;          //6B k\n  db _LOWER;          //6C l\n  db _LOWER;          //6D m\n  db _LOWER;          //6E n\n  db _LOWER;          //6F o\n  db _LOWER;          //70 p\n  db _LOWER;          //71 q\n  db _LOWER;          //72 r\n  db _LOWER;          //73 s\n  db _LOWER;          //74 t\n  db _LOWER;          //75 u\n  db _LOWER;          //76 v\n  db _LOWER;          //77 w\n  db _LOWER;          //78 x\n  db _LOWER;          //79 y\n  db _LOWER;          //7A z\n  db _PUNCT;          //7B {\n  db _PUNCT;          //7C |\n  db _PUNCT;          //7D }\n  db _PUNCT;          //7E ~\n  db _CONTROL;        //7F (DEL)\n\n  db _GRAPH;          //80\n  db _GRAPH;          //81\n  db _GRAPH;          //82\n  db _GRAPH;          //83\n"},"cpuchip/lib/drivers/":{"cpuchip/lib/drivers/drv_cscr.txt":"//------------------------------------------------------------------------------\n// ZCPU standard library and drivers set              (C) 2011 by Black Phoenix\n//\n// UDH-enabled console screen highspeed driver\n//------------------------------------------------------------------------------\n\n//Define to check if console screen driver is available\n#define CSCR_DRIVER\n\n//Maximum number of console screens supported\n#define MAX_CONSOLE_SCREENS 8\n\n//Console screen registers\n#define CURSOR_RATE       2043\n#define CURSOR_SIZE       2044\n#define CURSOR_POSITION   2045\n#define CURSOR_VISIBLE    2046\n#define LOW_SHIFT_COL     2031\n#define HIGH_SHIFT_COL    2032\n#define LOW_SHIFT_ROW     2033\n#define HIGH_SHIFT_ROW    2034\n#define SHIFT_ROWS        2038\n#define SHIFT_CELLS       2037\n#define CLEAR_SCREEN      2041\n#define BACKGROUND_COLOR  2042\n#define SCREEN_ACTIVE     2047\n#define SCREEN_ROTATION   2024\n#define SCREEN_BRIGHTNESS 2036\n\n//Driver data\nchar* cscrOffsets[MAX_CONSOLE_SCREENS];\nfloat cscrDevices[MAX_CONSOLE_SCREENS];\nchar* cscrCharacterPointer[MAX_CONSOLE_SCREENS];\nfloat cscrSelectedScreen;\n\n#ifdef UDH_DRIVER\n//Update console screen offsets\nvoid cscrUDHQueryFunction() {\n  float i,n;\n  n = udhGetDevices(11,MAX_CONSOLE_SCREENS,cscrDevices);\n  for (i = 0; i < n; i++) {\n    cscrOffsets[i] = udhGetDeviceOffset(cscrDevices[i]);\n  }\n}\n#endif\n\n//Initialize console screen driver. screenOffset may be 0 if using UDH\nvoid cscrInitialize(char* screenOffset) {\n  float i;\n\n  for (i = 0; i < MAX_CONSOLE_SCREENS; i++) {\n    cscrOffsets[i] = screenOffset;\n  }\n\n#ifdef UDH_DRIVER\n    if (!screenOffset) {\n      udhRegisterDriver(cscrUDHQueryFunction);\n      cscrUDHQueryFunction();\n    }\n#endif\n  cscrSelectedScreen = 0;\n}\n\nfloat cscrPresent(float screen) {\n  return cscrOffsets[cscrSelectedScreen] != 0;\n}\n\nvoid cscrSelect(float screen) {\n  cscrSelectedScreen = screen;\n  max cscrSelectedScreen,0;\n  min cscrSelectedScreen,MAX_CONSOLE_SCREENS;\n}\n\nvoid cscrSetActive(float clk) {\n  if (!cscrOffsets[cscrSelectedScreen]) return;\n  *(cscrOffsets[cscrSelectedScreen]+SCREEN_ACTIVE) = clk;\n}\n\nvoid cscrClear() {\n  if (!cscrOffsets[cscrSelectedScreen]) return;\n  *(cscrOffsets[cscrSelectedScreen]+CLEAR_SCREEN) = 1;\n  cscrCharacterPointer[cscrSelectedScreen] = 0;\n}\n\nvoid cscrSetBackground(float col) {\n  if (!cscrOffsets[cscrSelectedScreen]) return;\n  *(cscrOffsets[cscrSelectedScreen]+BACKGROUND_COLOR) = col;\n}\n\nvoid cscrSetRotation(float rot) {\n  *(cscrOffsets[cscrSelectedScreen]+SCREEN_ROTATION) = rot;\n}\n\nvoid cscrSetBrightness(float bright) {\n  *(cscrOffsets[cscrSelectedScreen]+SCREEN_BRIGHTNESS) = bright;\n}\n\nvoid cscrLoadImage(char* imgdata) {\n  if (!cscrOffsets[cscrSelectedScreen]) return;\n\n  preserve ESI,EDI;\n  ESI = imgdata;\n  EDI = cscrOffsets[cscrSelectedScreen];\n  mcopy 30*18*2;\n}\n\nvoid cscrPutLine(char* scrptr, float col, char* str) {\n  if (!cscrOffsets[cscrSelectedScreen]) return;\n  char* curptr = scrptr;\n\n  while (*str) {\n    *(cscrOffsets[cscrSelectedScreen]+curptr*2+0) = *str;\n    *(cscrOffsets[cscrSelectedScreen]+curptr*2+1) = col;\n\n    str++;\n    curptr++;\n  }\n}\n\nvoid cscrPutChar(char* scrptr, float col, char ch) {\n  if (!cscrOffsets[cscrSelectedScreen]) return;\n\n  *(cscrOffsets[cscrSelectedScreen]+scrptr*2+0) = ch;\n  *(cscrOffsets[cscrSelectedScreen]+scrptr*2+1) = col;\n}\n\nvoid cscrNewLine() {\n  if (!cscrOffsets[cscrSelectedScreen]) return;\n\n  cscrCharacterPointer[cscrSelectedScreen] /= 30;\n  fint cscrCharacterPointer[cscrSelectedScreen];\n  cscrCharacterPointer[cscrSelectedScreen] = (cscrCharacterPointer[cscrSelectedScreen]+1)*30;\n\n  if (cscrCharacterPointer[cscrSelectedScreen] >= 30*18) {\n    cscrCharacterPointer[cscrSelectedScreen] = cscrCharacterPointer[cscrSelectedScreen] - 30;\n    *(cscrOffsets[cscrSelectedScreen]+SHIFT_ROWS) = 1;\n  }\n}\n\nvoid cscrPrintLine(char* str, float col) {\n  if (!cscrOffsets[cscrSelectedScreen]) return;\n\n  while (*str) {\n    if (*str == '\\n') {\n      cscrNewLine();\n      str++;\n      if (*str == 0) return;\n    }\n\n    *(cscrOffsets[cscrSelectedScreen]+cscrCharacterPointer[cscrSelectedScreen]*2+0) = *str;\n    *(cscrOffsets[cscrSelectedScreen]+cscrCharacterPointer[cscrSelectedScreen]*2+1) = col;\n\n    cscrCharacterPointer[cscrSelectedScreen]++;\n    if (cscrCharacterPointer[cscrSelectedScreen] >= 30*18) cscrNewLine();\n    str++;\n  }\n}\n\nvoid cscrPrintNumber(float num, float col) {\n  if (!cscrOffsets[cscrSelectedScreen]) return;\n\n  float ndig,a;\n  a = num;\n  ndig = 0;\n  while (a > 0) {\n    ndig++;\n    a /= 10;\n    fint a;\n  }\n  max ndig,1;\n  a = num;\n\n  cscrCharacterPointer[cscrSelectedScreen] = cscrCharacterPointer[cscrSelectedScreen] + ndig;\n  char* charPtr = cscrCharacterPointer[cscrSelectedScreen] - 1;\n  while (ndig > 0) {\n    preserve EDX;\n    mov EDX,a;\n    mod EDX,10;\n    add EDX,48;\n\n    *(cscrOffsets[cscrSelectedScreen]+charPtr*2+0) = EDX;\n    *(cscrOffsets[cscrSelectedScreen]+charPtr*2+1) = col;\n    charPtr--;\n\n    a /= 10;\n    fint a;\n\n    ndig--;\n  }\n}\n\nvoid cscrSetCursor(float x, y) {\n  if (!cscrOffsets[cscrSelectedScreen]) return;\n  cscrCharacterPointer[cscrSelectedScreen] = x+y*30;\n}\n","cpuchip/lib/drivers/drv_udh.txt":"//------------------------------------------------------------------------------\n// ZCPU standard library and drivers set              (C) 2011 by Black Phoenix\n//\n// Universal device host driver. Only supports 8 devices right now\n//------------------------------------------------------------------------------\n\n#define UDH_DRIVER\n\n//Maximum number of devices supported\n#define MAX_UDH_DEVICES 8\n\n//Address range of a single device\n#define MAX_UDH_ADDRESS_RANGE 4*1024\n\n//Maximum number of drivers that may register with UDH\n#define MAX_UDH_DRIVERS 8\n\n//Device name/string data\nstring udhDeviceString0,\"None\";\nstring udhDeviceString1,\"Unknown\";\nstring udhDeviceString2,\"Extended bus\";\nstring udhDeviceString3,\"Address bus\";\nstring udhDeviceString4,\"Zyelios CPU\";\nstring udhDeviceString5,\"Zyelios GPU\";\nstring udhDeviceString6,\"Zyelios SPU\";\nstring udhDeviceString7,\"Flash EEPROM\";\nstring udhDeviceString8,\"ROM\";\nstring udhDeviceString9,\"Data bus\";\nstring udhDeviceString10,\"CD Ray\";\nstring udhDeviceString11,\"Console screen\";\nstring udhDeviceString12,\"Digital screen\";\nstring udhDeviceString13,\"Data plug\";\nstring udhDeviceString14,\"Data socket\";\nstring udhDeviceString15,\"Keyboard\";\nstring udhDeviceString16,\"Oscilloscope\";\nstring udhDeviceString17,\"Sound emitter\";\nstring udhDeviceString18,\"Constant value\";\nstring udhDeviceString19,\"Data port\";\nstring udhDeviceString20,\"RAM\";\nudhDeviceName:\n  db udhDeviceString0, udhDeviceString1, udhDeviceString2;\n  db udhDeviceString3, udhDeviceString4, udhDeviceString5;\n  db udhDeviceString6, udhDeviceString7, udhDeviceString8;\n  db udhDeviceString9, udhDeviceString10,udhDeviceString11;\n  db udhDeviceString12,udhDeviceString13,udhDeviceString14;\n  db udhDeviceString15,udhDeviceString16,udhDeviceString17;\n  db udhDeviceString18,udhDeviceString19,udhDeviceString20;\n\n//Extended bus offset\nchar* udhBusOffset;\n\n//List of callbacks to call when querying devices\nvoid* udhQueryCallback[MAX_UDH_DRIVERS];\nfloat udhQueryCallbackCount = 0;\n\nfloat udhSetBusAddress(char* extOffset) {\n  udhBusOffset = extOffset;\n  udhQueryDevices();\n}\n\nvoid udhQueryDevices() {\n  float i;\n\n  //Run the query\n  udhBusOffset[16] = 32+MAX_UDH_DEVICES;\n  udhBusOffset[17] = 1;\n\n  //Reconfigure all devices\n  //FIXME: only supports single extended bus right now\n  for (i = 0; i < 8; i++) {\n    udhBusOffset[i*2+0] = (4*1024)*i;\n    udhBusOffset[i*2+1] = (4*1024)*i+((4*1024)-1);\n  }\n\n  //Update all drivers\n  for (i = 0; i < udhQueryCallbackCount; i++) {\n    void* functionPtr = udhQueryCallback[i];\n    functionPtr();\n  }\n}\n\nvoid udhRegisterDriver(void* queryDeviceFunction) {\n  udhQueryCallback[udhQueryCallbackCount] = queryDeviceFunction;\n  if (udhQueryCallbackCount < MAX_UDH_DRIVERS) udhQueryCallbackCount++;\n}\n\nfloat udhGetDeviceType(float busIndex) {\n  return udhBusOffset[32+busIndex];\n}\n\nfloat udhGetDeviceOffset(float busIndex) {\n  return 65536+32+MAX_UDH_DEVICES+udhBusOffset[busIndex*2];\n}\n\nchar* udhGetDeviceName(float busIndex) {\n  float deviceType = udhGetDeviceType(busIndex);\n  if ((deviceType >= 0) && (deviceType <= 20)) {\n    return udhDeviceName[deviceType];\n  } else {\n    return udhDeviceName[1];\n  }\n}\n\nvoid udhSetDeviceOffsetSize(float busIndex, char* offst, char* size) {\n  udhBusOffset[busIndex*2+0] = offst;\n  udhBusOffset[busIndex*2+1] = offst+size-1;\n}\n\nfloat udhGetNumDevices() {\n  return MAX_UDH_DEVICES;\n}\n\nfloat udhGetDevices(float type, float maxCount, char* deviceList) {\n  float i,devPtr,n;\n\n  devPtr = deviceList;\n  n = 0;\n  for (i = 0; i < MAX_UDH_DEVICES; i++) {\n    if ((udhGetDeviceType(i) == type) && (n < maxCount)) {\n      n++;\n      *devPtr++ = i;\n    }\n  }\n\n  return n;\n}\n"}}}}