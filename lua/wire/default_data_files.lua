//{"expression2/":{"expression2/_helloworld_.txt":"@name Hello World\r\n@inputs A B\r\n@outputs Add Sub Mul Div\r\n@outputs GreaterThan Highest Lowest\r\n@outputs Vector:vector\r\n@persist D\r\n@trigger all\r\n\r\nAdd = A + B\r\nSub = A - B\r\nMul = A * B\r\nDiv = A / B\r\n\r\nGreaterThan = A > B\r\n\r\nif(A > B) {\r\n    Highest = A, Lowest = B\r\n} else {\r\n    Highest = B, Lowest = A\r\n}\r\n\r\nVector = vec(A, B, 0)\r\nVector = Vector + vec(0, 0, A + B)\r\nVector = Vector:normalized()"},"soundlists/":{"soundlists/common_sounds.txt":"AlyxEMP.Charge | property\r\nAlyxEMP.Discharge | property\r\nAlyxEMP.Stop | property\r\nBaseExplosionEffect.Sound | property\r\nBaseGrenade.BounceSound | property\r\nBaseGrenade.Explode | property\r\nBaseGrenade.StopSounds | property\r\nBullets.DefaultNearmiss | property\r\nBullets.GunshipNearmiss | property\r\nBullets.StriderNearmiss | property\r\nFX_RicochetSound.Ricochet | property\r\nFuncTank.Fire | property\r\nFunc_Tank.BeginUse | property\r\nGenericNPC.GunSound | property\r\nGrenade.Blip | property\r\nGrenadeBeam.HitSound | property\r\nGrenadeBottle.Detonate | property\r\nGrenadeBugBait.Splat | property\r\nGrenadeHomer.StopSounds | property\r\nGrenadePathfollower.StopSounds | property\r\nGrenadeScanner.StopSound | property\r\nGrenade_Molotov.Detonate | property\r\nTripwireGrenade.ShootRope | property\r\nWaterExplosionEffect.Sound | property\r\nWeaponFrag.Roll | property\r\nWeaponFrag.Throw | property\r\nWeapon_357.OpenLoader | property\r\nWeapon_357.Reload | property\r\nWeapon_357.RemoveLoader | property\r\nWeapon_357.ReplaceLoader | property\r\nWeapon_357.Single | property\r\nWeapon_357.Spin | property\r\nWeapon_AR2.Double | property\r\nWeapon_AR2.Empty | property\r\nWeapon_AR2.NPC_Double | property\r\nWeapon_AR2.NPC_Reload | property\r\nWeapon_AR2.NPC_Single | property\r\nWeapon_AR2.Reload | property\r\nWeapon_AR2.Reload_Push | property\r\nWeapon_AR2.Reload_Rotate | property\r\nWeapon_AR2.Single | property\r\nWeapon_AR2.Special1 | property\r\nWeapon_AR2.Special2 | property\r\nWeapon_Binoculars.Reload | property\r\nWeapon_Binoculars.Special1 | property\r\nWeapon_Binoculars.Special2 | property\r\nWeapon_Brickbat.Special1 | property\r\nWeapon_Bugbait.Splat | property\r\nWeapon_CombineGuard.Special1 | property\r\nWeapon_Crossbow.BoltElectrify | property\r\nWeapon_Crossbow.BoltFly | property\r\nWeapon_Crossbow.BoltHitBody | property\r\nWeapon_Crossbow.BoltHitWorld | property\r\nWeapon_Crossbow.BoltSkewer | property\r\nWeapon_Crossbow.Reload | property\r\nWeapon_Crossbow.Single | property\r\nWeapon_Crowbar.Melee_Hit | property\r\nWeapon_Crowbar.Melee_HitWorld | property\r\nWeapon_Crowbar.Single | property\r\nWeapon_Extinguisher.Double | property\r\nWeapon_Extinguisher.Empty | property\r\nWeapon_Extinguisher.NPC_Double | property\r\nWeapon_Extinguisher.NPC_Reload | property\r\nWeapon_Extinguisher.NPC_Single | property\r\nWeapon_Extinguisher.Reload | property\r\nWeapon_Extinguisher.Single | property\r\nWeapon_Extinguisher.Special1 | property\r\nWeapon_FlareGun.Burn | property\r\nWeapon_FlareGun.Reload | property\r\nWeapon_FlareGun.Single | property\r\nWeapon_Gauss.ChargeLoop | property\r\nWeapon_IRifle.Empty | property\r\nWeapon_IRifle.Single | property\r\nWeapon_MegaPhysCannon.Charge | property\r\nWeapon_MegaPhysCannon.ChargeZap | property\r\nWeapon_MegaPhysCannon.Drop | property\r\nWeapon_MegaPhysCannon.DryFire | property\r\nWeapon_MegaPhysCannon.HoldSound | property\r\nWeapon_MegaPhysCannon.Launch | property\r\nWeapon_MegaPhysCannon.Pickup | property\r\nWeapon_Mortar.Impact | property\r\nWeapon_Mortar.Incomming | property\r\nWeapon_Mortar.Single | property\r\nWeapon_PhysCannon.Charge | property\r\nWeapon_PhysCannon.CloseClaws | property\r\nWeapon_PhysCannon.Drop | property\r\nWeapon_PhysCannon.DryFire | property\r\nWeapon_PhysCannon.HoldSound | property\r\nWeapon_PhysCannon.Launch | property\r\nWeapon_PhysCannon.OpenClaws | property\r\nWeapon_PhysCannon.Pickup | property\r\nWeapon_PhysCannon.TooHeavy | property\r\nWeapon_Physgun.HeavyObject | property\r\nWeapon_Physgun.LightObject | property\r\nWeapon_Physgun.LockedOn | property\r\nWeapon_Physgun.Off | property\r\nWeapon_Physgun.On | property\r\nWeapon_Physgun.Scanning | property\r\nWeapon_Physgun.Special1 | property\r\nWeapon_Pistol.Burst | property\r\nWeapon_Pistol.Empty | property\r\nWeapon_Pistol.NPC_Reload | property\r\nWeapon_Pistol.NPC_Single | property\r\nWeapon_Pistol.Reload | property\r\nWeapon_Pistol.Single | property\r\nWeapon_Pistol.Special1 | property\r\nWeapon_Pistol.Special2 | property\r\nWeapon_RPG.LaserOff | property\r\nWeapon_RPG.LaserOn | property\r\nWeapon_RPG.NPC_Single | property\r\nWeapon_RPG.Single | property\r\nWeapon_SMG1.Burst | property\r\nWeapon_SMG1.Double | property\r\nWeapon_SMG1.Empty | property\r\nWeapon_SMG1.NPC_Reload | property\r\nWeapon_SMG1.NPC_Single | property\r\nWeapon_SMG1.Reload | property\r\nWeapon_SMG1.Single | property\r\nWeapon_SMG1.Special1 | property\r\nWeapon_SMG1.Special2 | property\r\nWeapon_Shotgun.Double | property\r\nWeapon_Shotgun.Empty | property\r\nWeapon_Shotgun.NPC_Reload | property\r\nWeapon_Shotgun.NPC_Single | property\r\nWeapon_Shotgun.Reload | property\r\nWeapon_Shotgun.Single | property\r\nWeapon_Shotgun.Special1 | property\r\nWeapon_SniperRifle.NPC_Reload | property\r\nWeapon_SniperRifle.NPC_Single | property\r\nWeapon_SniperRifle.Reload | property\r\nWeapon_SniperRifle.Single | property\r\nWeapon_SniperRifle.Special1 | property\r\nWeapon_SniperRifle.Special2 | property\r\nWeapon_StunStick.Activate | property\r\nWeapon_StunStick.Deactivate | property\r\nWeapon_StunStick.Melee_Hit | property\r\nWeapon_StunStick.Melee_HitWorld | property\r\nWeapon_StunStick.Melee_Miss | property\r\nWeapon_StunStick.Swing | property\r\nWeapon_functank.Single | property\r\n"},"wire_version.txt":"gm13-401-gf291c42\r\n","gpuchip/":{"gpuchip/examples/":{"gpuchip/examples/3d_icosahedron.txt":"// Author: Drunkie\r\n// Description: Draws a 3D icosahedron model (solid and wireframe)\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nvoid Main()\r\n{\r\n    glSleep( 40 ); // Sleep for 40 milliseconds (Reduces fps lag)\r\n    glClear( 0, 0, 0 ); // Clear screen\r\n    \r\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe to [-1 to 1] mode \r\n    glVertexPipe( GL_VPIPE_XYZTRANSFORM ); // Set vertex pipe to xyz transformation\r\n\r\n    glLightPos( 0, 0, -50 ); // Set the light position\r\n    glLightColor( 255, 255, 255, 1 ); // Set the light color\r\n    \r\n    glLookAt(\r\n        0, 0, -2.25, // Camera pos\r\n        0, 0, 0, // Camera target\r\n        0, 1, 0 // Camera up\r\n    ); \r\n    \r\n    // Create variable to hold curtime\r\n    float time;\r\n    timer time;\r\n   \r\n    // Create perspective and matrix transformations\r\n    glPerspective( 30, 1, 1, 20 ); // FOV, ASPECT RATIO, ZNEAR, ZFAR\r\n    glRotate( 1, 1, 0, time ); // AXIS X, Y, Z, ANGLE W\r\n    glTranslate( 0, 0, 0 ); // TRANSLATION X, Y, Z\r\n    glScale( 1, 1, 1, 0 ); // SCALE X, Y, Z\r\n    \r\n    glEnable( GL_VERTEX_BUFFER ); // Enable vertex buffer \r\n    glEnable( GL_VERTEX_ZSORT ); // Enable Z sorting\r\n    glEnable( GL_VERTEX_LIGHTING ); // Enable vertex lighting\r\n    //glEnable( GL_VERTEX_CULLING ); // Enable face culling\r\n    \r\n    // Solid 3D polygon\r\n    glFillMode( GL_FILL_SOLID ); // Set fillmode as solid\r\n    glColor4( 100, 149, 237, 180 ); // Set the draw color with alpha\r\n    glPoly3D( vertexBuffer, 20 ); // Draw 3D polygon\r\n    glFlush(); // Flush the vertex buffer to the screen\r\n    \r\n    glDisable( GL_VERTEX_LIGHTING ); // Enable vertex lighting\r\n    \r\n    // Wireframe 3D polygon\r\n    glLineWidth( 1 ); // Set line width of wireframe\r\n    glFillMode( GL_FILL_WIREFRAME ); // Set fillmode as wireframe\r\n    glColor4( 255, 255, 255, 255 ); // Set the draw color with alpha\r\n    glPoly3D( vertexBuffer, 20 ); // Draw 3D polygon\r\n    glFlush(); // Flush the vertex buffer to the screen\r\n    \r\n    glExit(); // Exit\r\n}\r\n\r\n// The vertex data for our model\r\nvertexBuffer:\r\ndb 0,0,1; db 0,0.9,0.5; db 0.9,0.3,0.4;\r\ndb 0,0,1; db -0.9,0.3,0.4; db 0,0.9,0.5;\r\ndb 0,0,1; db -0.5,-0.7,0.4; db -0.9,0.3,0.4;\r\ndb 0,0,1; db 0.5,-0.7,0.4; db -0.5,-0.7,0.4;\r\ndb 0,0,1; db 0.9,0.3,0.4; db 0.5,-0.7,0.4;\r\ndb 0.9,-0.3,-0.4; db 0.9,0.3,0.4; db 0.5,0.7,-0.4;\r\ndb 0,0.9,0.5; db 0.5,0.7,-0.4; db 0.9,0.3,0.4;\r\ndb 0,0.9,0.5; db -0.5,0.7,-0.4; db 0.5,0.7,-0.4;\r\ndb 0,0.9,0.5; db -0.9,0.3,0.4; db -0.5,0.7,-0.4;\r\ndb -0.9,-0.3,-0.4; db -0.5,0.7,-0.4; db -0.9,0.3,0.4;\r\ndb -0.9,-0.3,-0.4; db -0.9,0.3,0.4; db -0.5,-0.7,0.4;\r\ndb -0.9,-0.3,-0.4; db -0.5,-0.7,0.4; db 0,-0.9,-0.5;\r\ndb 0.5,-0.7,0.4; db 0,-0.9,-0.5; db -0.5,-0.7,0.4;\r\ndb 0.5,-0.7,0.4; db 0.9,-0.3,-0.4; db 0,-0.9,-0.5;\r\ndb 0.5,-0.7,0.4; db 0.9,0.3,0.4; db 0.9,-0.3,-0.4;\r\ndb 0,0,-1; db 0,-0.9,-0.5; db 0.9,-0.3,-0.4;\r\ndb 0,0,-1; db 0.9,-0.3,-0.4; db 0.5,0.7,-0.4;\r\ndb 0,0,-1; db 0.5,0.7,-0.4 db -0.5,0.7,-0.4;\r\ndb 0,0,-1; db -0.5,0.7,-0.4; db -0.9,-0.3,-0.4;\r\ndb 0,0,-1; db -0.9,-0.3,-0.4; db 0,-0.9,-0.5;\r\n","gpuchip/examples/hud_fighter.txt":"//Aircraft hud\r\n//port0 - ROLL\r\n//port1 - PITCH\r\n//port2 - YAW (heading)\r\n//port3 - speed (units/sec)\r\n//port4 - altitude (units)\r\n//port5 - radar altitude (put ranger under your plane, and attach to this)\r\n//port6 - flaps active, 1 or 0\r\n//port7 - go to \"Gates - Time\", and find \"Derivative\". Attach this to derivative, and derivative to altitude (vertical speed)\r\n\r\n//Artiftical horizon\r\nin eax,0; //Roll\r\nin ebx,1; //Pitch\r\n\r\n//mul ebx,0.017453292;\r\nmul eax,0.017453292;\r\nadd eax,1.57;\r\n\r\ndiv ebx,90;\r\nmul ebx,512;\r\nadd ebx,256;\r\n\r\nmov #horizon_moveoffset.y,ebx;\r\n\r\ndrotatescale eax,1;\r\ndmove horizon_moveoffset;\r\n\r\ndcolor art_sky;\r\ndrectwh horizon_sky_offset,horizon_size;\r\ndcolor art_grnd;\r\ndrectwh horizon_grnd_offset,horizon_size;\r\n\r\ndcolor hud_text;\r\ndsetsize 20;\r\nmov eax,-45;\r\n_horizon_text:\r\n  mov ebx,eax;\r\n  mul ebx,5.68;\r\n  sub ebx,10;\r\n  mov #horizon_textpos1.y,ebx;\r\n  mov #horizon_textpos2.y,ebx; add ebx,9;\r\n  mov #horizon_rectpos1.y,ebx; add ebx,2;\r\n  mov #horizon_rectpos2.y,ebx;\r\n\r\n  drect horizon_rectpos1,horizon_rectpos2;\r\n  dwritei horizon_textpos1,eax;\r\n  dwritei horizon_textpos2,eax;\r\n\r\n  add eax,15;\r\n  cmp eax,45;\r\n  jle _horizon_text;\r\n\r\n//Reset\r\ndmove 0;\r\ndrotatescale 0,1;\r\n\r\n//Border around art horizon\r\ndcolor border_color;\r\ndrect border_p1,border_p2;\r\ndrect border_p3,border_p4;\r\ndrect border_p5,border_p6;\r\ndrect border_p7,border_p8;\r\ndcolor border_color2;\r\ndrect border_p9,border_p10;\r\n\r\n//Draw hud stuff\r\nmov #roll,port0;\r\nmov #pitch,port1;\r\nmov #hdg,port2; add #hdg,180;\r\nmov #spd,port3; div #spd,17.6;\r\nmov #alt,port4;\r\nadd #alt,12000;\r\ndiv #alt,12;\r\nmov #ralt,port5; div #ralt,12;\r\nmov #vspd,port7; div #vspd,17.6;\r\ndcolor hud_text;\r\ndwritefmt hud_pos1,hud_text1;\r\ndsetsize 16;\r\ndwritefmt hud_pos2,hud_text2;\r\n\r\ndcolor hud_text;\r\nmov eax,port6; mul eax,0.75; add eax,0.25;\r\ndshade eax;\r\ndwritefmt hud_pos3,hud_text3;\r\n\r\n\r\ndexit;\r\n\r\nvec2f hud_pos1,50,20;\r\nstring hud_text1,'ROLL %i %tPITCH %i%tHDG %i';\r\nalloc roll; \r\nalloc pitch;\r\nalloc hdg;\r\n\r\nvec2f hud_pos2,45,120;\r\nstring hud_text2,'SPD',10,'%ikt',10,10,'ALT',10,'%ift',10,10,'RALT',10,'%ift',10,10,'VSPD',10,'%ift/s';\r\nalloc spd;\r\nalloc alt;\r\nalloc ralt;\r\nalloc vspd;\r\n\r\nvec2f hud_pos3,45,400;\r\nstring hud_text3,'FLAPS';\r\n\r\n\r\nvec2f horizon_textpos1,96,0;\r\nvec2f horizon_textpos2,-64,0;\r\nvec2f horizon_rectpos1,-50,0;\r\nvec2f horizon_rectpos2,50,0;\r\ncolor hud_text,64,255,64;\r\n\r\ncolor border_color2,255,255,255;\r\ncolor border_color,30,30,30;\r\nvec2f border_p1,0,0;\r\nvec2f border_p2,128,512;\r\nvec2f border_p3,384,0;\r\nvec2f border_p4,512,512;\r\n\r\nvec2f border_p5,128,0;\r\nvec2f border_p6,384,64;\r\nvec2f border_p7,128,448;\r\nvec2f border_p8,384,512;\r\n\r\nvec2f border_p9,128,254;\r\nvec2f border_p10,384,258;\r\n\r\nvec2f horizon_sky_offset,-256,-512;\r\nvec2f horizon_grnd_offset,-256,0;\r\nvec2f horizon_size,512,512;\r\n\r\nvec2f horizon_moveoffset,256,256;\r\n\r\ncolor art_sky,24,144,255;\r\ncolor art_grnd,192,72,0;\r\n","gpuchip/examples/stargate.txt":"//STARGATE DIAL COMPUTER MAIN DISPLAY (realistic colors)\r\n//\r\n//How to connect:\r\n//GPU IOBus to Data Port\r\n//Port0 to \"Open\"\r\n//Port1 to \"Active\"\r\n//Port2 to \"Chevron\"\r\n//Port3 to \"Inbound\"\r\n//Port4 to iris\r\n//\r\n//That's all!\r\n\r\ndiv #65525,1.33;\r\nmov #65485,16; //65485 is the circle quality register\r\n\r\n//24 means circles have 24 sides\r\n//You can have up to 128 sides, but that LAGS\r\n//32 sides is not even noticable comparing to 128\r\n\r\n//= Misc decorations ==================\r\n\r\ndcolor stargate_out_ring;\r\ndcircle center,250;\r\ndcolor stargate_middle_ring;\r\ndcircle center,240;\r\ndcolor stargate_out_ring;\r\ndcircle center,223;\r\n\r\n//= Rotating ring =====================\r\nmov #65485,12;\r\ndcolor stargate_inner_ring;\r\n\r\nin ecx,2; //This block checks if chevron 7 is engaged\r\ncmp ecx,7; //If yes, dont spin\r\nmov eax,0;\r\njge _norotate;\r\n  timer eax;\r\n_norotate:\r\n\r\nin ebx,1; //This one checks if stargate is active\r\nmul eax,ebx;\r\n\r\nin ebx,3; neg ebx; add ebx,1; //This one checks if its inbound\r\nmul eax,ebx; //wormhole\r\n\r\ndrotatescale eax,1; //rotate by EAX radians\r\ndmove center;\r\ndcircle 0,220;\r\n\r\ndrotatescale 0,1; //Reset scale/movment\r\ndmove 0;\r\n\r\n//= Inner ring around EH ==============\r\nmov #65485,24;\r\ndcolor stargate_out_ring;\r\ndcircle center,190;\r\n\r\n\r\n//= EH ================================\r\ndcolor black;\r\ndcircle center,180; //draw black hole instead of event horizon\r\n\r\ndcolor stargate_eventhorizon;\r\n\r\nin ebx,0; //Stargate active?\r\ncmp ebx,0;\r\nmov eax,0;\r\nje _active;\r\n  rand eax;\r\n  mul eax,0.1;\r\n  add eax,0.9;\r\n_active:\r\n\r\nin ebx,0; mul ebx,180;\r\n\r\nmul #eventhorizon_radius,0.99;\r\nmul ebx,1.01;\r\nadd #eventhorizon_radius,ebx;\r\ndiv #eventhorizon_radius,2;\r\n\r\n\r\ndshade eax;\r\ndcircle center,#eventhorizon_radius;\r\n\r\n//= Iris ==============================\r\nmov edx,port4;\r\nneg edx; add edx,1;\r\n\r\nmov eax,#iris_status;\r\nsub eax,edx;\r\nfabs eax,eax;\r\n\r\ndmuldt ecx,8;\r\n\r\ncmp eax,0.02;\r\njl _donothing;\r\n  cmp #iris_status,edx;\r\n  jl _lower;\r\n    sub #iris_status,ecx;\r\n  jmp _donothing;\r\n  _lower:\r\n    add #iris_status,ecx;\r\n_donothing:\r\n\r\nmov #iris1.y,#iris_status;\r\nmul #iris1.y,#iris2.y;\r\n\r\ndmove center;\r\n\r\nmov ecx,12;\r\n_iris:\r\n  fsin ebx,ecx; fabs ebx,ebx; div ebx,10; add ebx,0.7;\r\n\r\n  mov eax,ecx; mul eax,0.490; add eax,0.01; //0.697\r\n  add eax,#iris_status;\r\n\r\n  drotatescale eax,1;\r\n\r\n  dcolor iris_color;\r\n  dshade ebx;\r\n\r\n  drect iris1,iris2;\r\nloop _iris;\r\n\r\ndmove 0;\r\n\r\n//= Chevrons ==========================\r\nmov eax,1; //Chevron ID\r\nin ebx,2;\r\ndmove center;\r\n_chevron_loop:\r\n  mov edx,eax; //Compute chevron angle in radians\r\n  mul edx,0.69815;\r\n  sub edx,1.23333;\r\n\r\n  drotatescale edx,1; //Rotate chevron polygon\r\n  dcolor stargate_chevron;\r\n\r\n  mov edx,eax:#chevron_triggers;\r\n\r\n  cmp edx,ebx; //Check if chevron is light up\r\n  jle _noshade;\r\n    dshade 0.25;\r\n  _noshade:\r\n\r\n  dvxpoly chevron_polygon,4; //draw chevron polygon\r\n\r\n  inc eax;\r\n  cmp eax,9;\r\n  jle _chevron_loop;\r\n\r\n//= Computer text =====================\r\ndrotatescale 0,1; //reset movement and scale\r\ndmove 0;\r\n\r\nin eax,3; //Is inbound?\r\ncmp eax,0;\r\nje _dexit;\r\n\r\n  timer eax; mul eax,2; fint eax; mod eax,2;\r\n  dcolor sgc_text;\r\n  dshade eax;\r\n\r\n  dsetsize 64; //draw message\r\n  dwrite sgc_inboundpos,sgc_inbound;\r\n\r\n_dexit:\r\ndexit;\r\n\r\n//= Helpers ===========================\r\n\r\nchevron_triggers:\r\ndb 9,4,5,6,7,1,2,3,8;\r\n// 1 2 3 4 5 6 7 8 9\r\n// Order in which chevrons light up\r\n// Only 1-7 are used though\r\n\r\n//=====================================\r\n\r\ncolor sgc_text,255,255,255;\r\n\r\nvector2f sgc_inboundpos,120,215;\r\nstring sgc_inbound,'INBOUND';\r\n\r\ncolor stargate_out_ring,    116,105, 76;\r\ncolor stargate_middle_ring, 93 , 85, 60;\r\ncolor stargate_inner_ring,  138,137,108;\r\ncolor stargate_eventhorizon, 93,114,162;\r\ncolor stargate_chevron,     250,162, 54;\r\ncolor iris_color,           192,192,192;\r\n\r\ncolor black,0,0,0;\r\n\r\nvector2f center,256,256;\r\n\r\nvector2f iris1,-44,0;\r\nvector2f iris2,44,175;\r\n\r\nvector2f chevcenter,-16,-256;\r\nvector2f chevsize,32,32;\r\n\r\nalloc eventhorizon_radius;\r\nalloc iris_status;\r\n\r\n//raw chevron poly data\r\n//format: <x> <y>\r\nchevron_polygon: //n=4\r\ndb -16,-251;\r\ndb 16,-251;\r\ndb 10,-230;\r\ndb -10,-230;\r\n","gpuchip/examples/sprite.txt":"// Author: Drunkie\r\n// Description: A very simple sprite example\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nvoid Main()\r\n{\r\n    // Enable vertex mode\r\n    glVertexMode( 1 );\r\n    \r\n    // Draw to sprite buffer\r\n    glSetRenderTarget( GL_BUFFER_BACK );\r\n    glClear( 0, 255, 0 );\r\n    \r\n    // Draw to vertex buffer (world)\r\n    glSetRenderTarget( GL_BUFFER_VERTEX );\r\n    glEnable( GL_VERTEX_TEXTURING );\r\n    \r\n    // Sample from sprite 0\r\n    glTextureSize( 256 );\r\n    glTexture( 0 );\r\n    glClear( 0, 255, 0 );\r\n    glRectWH( 128, 128, 256, 256 );\r\n    \r\n    glSetRenderTarget( GL_BUFFER_FRONT );\r\n   \r\n    glExit();\r\n}\r\n","gpuchip/examples/cube.txt":"//timer EAX;// div EAX,8;\r\n//fsin EAX,EAX;\r\n//mul EAX,512;\r\n//fabs EAX,EAX;\r\n//neg EAX;\r\n//add EAX,512;\r\n\r\ndcvxpipe 3; //-1..1 (opengl screen)\r\ndvxpipe  5; //matrix projection\r\n\r\n//Initialize transform\r\nmperspective mProjectionMatrix,vPerspective;\r\n\r\n//Render starts\r\ndclrscr  bg_color;\r\nmlookat mViewMatrix,vLookAt; //View matrix\r\n\r\ntimer eax;\r\nmov #vRotate.w,eax;\r\n\r\n//Rotate translate\r\nmrotate mRotateMatrix,vRotate;\r\nmtranslate mTranslateMatrix,vTranslate;\r\n\r\n//Create model matrix\r\nmmov mModelMatrix,mTranslateMatrix;\r\nmmul mModelMatrix,mRotateMatrix;\r\n\r\n//modelViewMatrix = ViewMatrix * modelMatrx\r\nmmov mModelViewMatrix,mViewMatrix;\r\nmmul mModelViewMatrix,mModelMatrix;\r\n\r\n//load matrix\r\nmload mModelViewMatrix;\r\nmloadproj mProjectionMatrix;\r\n\r\n//setup light\r\ndsetlight 0,lightdata;\r\n\r\n//setup buffer\r\ndenable 0; //Vertex buffer\r\ndenable 1; //ZSorting\r\ndenable 2; //Lighting\r\ndenable 3; //Face culling\r\n\r\n//render cube\r\ndcolor fg_color;\r\ndvxdata_3f cube2,12;\r\ndvxflush;\r\n\r\nddisable 0; //Disable everything!\r\nddisable 1;\r\nddisable 2;\r\nddisable 3;\r\n\r\ndcvxpipe 0;\r\ndvxpipe  0;\r\n\r\n//You can write some text here now\r\n//<right here>\r\ndexit;\r\n\r\n//========\r\ncube2:\r\ndb -1,-1,-1;\r\ndb 1,-1,-1;\r\ndb 1,1,-1;\r\ncube3:\r\ndb -1,-1,-1;\r\ndb 1,1,-1;\r\ndb -1,1,-1;\r\ncube4:\r\ndb 1,-1,1;\r\ndb -1,-1,1;\r\ndb 1,1,1;\r\ncube5:\r\ndb -1,-1,1;\r\ndb -1,1,1;\r\ndb 1,1,1;\r\ncube6:\r\ndb 1,-1,-1;\r\ndb -1,-1,-1;\r\ndb 1,-1,1;\r\ncube7:\r\ndb -1,-1,-1;\r\ndb -1,-1,1;\r\ndb 1,-1,1;\r\ncube8:\r\ndb -1,1,-1;\r\ndb 1,1,-1;\r\ndb 1,1,1;\r\ncube9:\r\ndb -1,1,1;\r\ndb -1,1,-1;\r\ndb 1,1,1;\r\ncube10:\r\ndb -1,-1,-1;\r\ndb -1,1,-1;\r\ndb -1,1,1;\r\ncube11:\r\ndb -1,-1,1;\r\ndb -1,-1,-1;\r\ndb -1,1,1;\r\ncube12:\r\ndb 1,1,-1;\r\ndb 1,-1,-1;\r\ndb 1,1,1;\r\ncube13:\r\ndb 1,-1,-1;\r\ndb 1,-1,1;\r\ndb 1,1,1;\r\n\r\nlightdata:\r\nvector4f lightpos,  0,50,-50,  0; //x y z <unused, will be falloff>\r\ncolor    lightcol,255,255,255,  1; //R G B Brightness\r\n//========\r\n\r\nmatrix mRotateMatrix;\r\nmatrix mTranslateMatrix;\r\n\r\nmatrix mProjectionMatrix;\t//This defines our projection to screen\r\nmatrix mViewMatrix;\t\t//This defines our camera transformations\r\n\r\nmatrix mModelMatrix;\t\t//This is our model transformations\r\nmatrix mModelViewMatrix;\t//This is our model relatively to camera transform\r\n\r\n\r\nvector4f vRotate,      1,  1,  1,  0; //<AXIS X Y Z> <ANGLE W>\r\nvector4f vTranslate,   0,  0,  0,  0; //<TRANLSATION X Y Z> <0>\r\nvector4f vPerspective, 30, 1.6,  1,  20; //<FOV> <ASPECT RATIO> <ZNEAR> <ZFAR>\r\n\r\nvLookAt:\r\nvector3f vLookAt_Eye,    0, 0, -5; //Where our camera is\r\nvector3f vLookAt_Center, 0, 0, 0;  //What we look at\r\nvector3f vLookAt_Up,     0, 1, 0;  //Where our matt-hat is\r\n\r\ncolor fg_color,255,255,25;\r\ncolor bg_color,64,32,12;","gpuchip/examples/verynice2.txt":"//Generated by WGUI tool. Get it at wiremod.com\r\n_page_0:\r\ndsetsize 16\r\ndcolor _c_0\r\ndrect _a_1,_a_2\r\ndcolor _c_1\r\ndrect _a_4,_a_5\r\ndcolor _c_2\r\ndrect _a_7,_a_8\r\ndcolor _c_3\r\ndrect _a_10,_a_11\r\ndcolor _c_3\r\ndrect _a_13,_a_14\r\ndcolor _c_2\r\nmov #_f_17,port0\r\ndwrite _a_16,_s_17\r\ndcolor _c_4\r\ndrect _a_19,_a_20\r\ndcolor _c_2\r\nmov #_f_23,port0\r\ndwrite _a_22,_s_23\r\ndcolor _c_4\r\ndwritefmt _a_25,_s_26\r\ndcolor _c_4\r\ndwritefmt _a_28,_s_29\r\ndcolor _c_4\r\ndwritefmt _a_31,_s_32\r\ndcolor _c_4\r\ndwritefmt _a_34,_s_35\r\ndcolor _c_4\r\ndwritefmt _a_37,_s_38\r\ndcolor _c_4\r\ndwritefmt _a_40,_s_41\r\ndcolor _c_4\r\ndwritefmt _a_43,_s_44\r\ndcolor _c_4\r\ndwritefmt _a_46,_s_47\r\ndcolor _c_3\r\ndrect _a_49,_a_50\r\ndcolor _c_2\r\nmov #_f_53,port0\r\ndwrite _a_52,_s_53\r\ndcolor _c_3\r\ndrect _a_55,_a_56\r\ndcolor _c_2\r\nmov #_f_59,port0\r\ndwrite _a_58,_s_59\r\ndcolor _c_2\r\ndwritefmt _a_61,_s_62\r\ndcolor _c_2\r\ndwritefmt _a_64,_s_65\r\ndcolor _c_2\r\ndwritefmt _a_67,_s_68\r\ndcolor _c_2\r\ndwritefmt _a_70,_s_71\r\ndcolor _c_2\r\ndwritefmt _a_73,_s_74\r\ndcolor _c_2\r\ndwritefmt _a_76,_s_77\r\ndexit\r\n\r\ncolor _c_0,0,0,160\r\nvec2f _a_1,8,8\r\nvec2f _a_2,504,504\r\ncolor _c_1,7,51,122\r\nvec2f _a_4,16,16\r\nvec2f _a_5,496,496\r\ncolor _c_2,0,0,0\r\nvec2f _a_7,24,24\r\nvec2f _a_8,488,488\r\ncolor _c_3,192,192,192\r\nvec2f _a_10,32,32\r\nvec2f _a_11,480,216\r\nvec2f _a_13,32,224\r\nvec2f _a_14,480,392\r\nvec2f _a_16,40,40\r\nstring _s_17,'VERYNICE GUI V2.1 Initialized...'\r\nalloc _f_17,0\r\ncolor _c_4,128,128,128\r\nvec2f _a_19,32,64\r\nvec2f _a_20,480,72\r\nvec2f _a_22,40,232\r\nstring _s_23,'Raw data feed:'\r\nalloc _f_23,0\r\nvec2f _a_25,88,256\r\nstring _s_26,'Input port 0: %f'\r\nvec2f _a_28,88,272\r\nstring _s_29,'Input port 1: %f'\r\nvec2f _a_31,88,288\r\nstring _s_32,'Input port 2: %f'\r\nvec2f _a_34,88,304\r\nstring _s_35,'Input port 3: %f'\r\nvec2f _a_37,88,320\r\nstring _s_38,'Input port 4: %f'\r\nvec2f _a_40,88,336\r\nstring _s_41,'Input port 5: %f'\r\nvec2f _a_43,88,352\r\nstring _s_44,'Input port 6: %f'\r\nvec2f _a_46,88,368\r\nstring _s_47,'Input port 7: %f'\r\nvec2f _a_49,32,400\r\nvec2f _a_50,248,480\r\nvec2f _a_52,40,408\r\nstring _s_53,'Vector feed 1:'\r\nalloc _f_53,0\r\nvec2f _a_55,264,400\r\nvec2f _a_56,480,480\r\nvec2f _a_58,272,408\r\nstring _s_59,'Vector feed 2:'\r\nalloc _f_59,0\r\nvec2f _a_61,40,424\r\nstring _s_62,'X: %f'\r\nvec2f _a_64,40,440\r\nstring _s_65,'Y: %f'\r\nvec2f _a_67,40,456\r\nstring _s_68,'Z: %f'\r\nvec2f _a_70,272,424\r\nstring _s_71,'X: %f'\r\nvec2f _a_73,272,440\r\nstring _s_74,'Y: %f'\r\nvec2f _a_76,272,456\r\nstring _s_77,'Z: %f'\r\n\r\n","gpuchip/examples/verynice1.txt":"dcolor c1;\r\ndrect p1,p2;\r\ndcolor c2;\r\ndrect p3,p4;\r\ndcolor c3;\r\ndrect p5,p6;\r\n\r\nmov #textpos1.y,80;\r\n\r\ndcolor c4;\r\ndsetsize 12;\r\ndwrite textpos1,text1;\r\n\r\nmov ecx,0;\r\nport_loop:\r\n  add #textpos1.y,18;\r\n  mov #textpos2.y,#textpos1.y;\r\n\r\n  mov #textpos2.x,#textpos1.x;\r\n  add #textpos2.x,90;\r\n  dwrite textpos1,text2;\r\n  dwritei textpos2,ecx;\r\n\r\n  in eax,ecx;\r\n\r\n  mov #textpos2.x,#textpos1.x;\r\n  add #textpos2.x,192;\r\n  dwritef textpos2,eax;\r\n\r\n  inc ecx;\r\n  cmp ecx,18;\r\n  jl port_loop;\r\n\r\ndexit;\r\n\r\nstring text1,'VERYNICE HUD SYSTEM INITIALIZED... VER 1.0';\r\nstring text2,'INPUT PORT        VALUE';\r\n\r\nvec2f textpos1,80,80;\r\nvec2f textpos2,80,80;\r\n\r\ncolor c1,0,0,255;\r\ncolor c2,0,0,127;\r\ncolor c3,0,0,64;\r\ncolor c4,255,255,255;\r\n\r\nvec2f p1,50,50;\r\nvec2f p2,450,450;\r\n\r\nvec2f p3,60,60;\r\nvec2f p4,430,430;\r\n\r\nvec2f p5,70,70;\r\nvec2f p6,440,440;","gpuchip/examples/trig.txt":"// Author: Jasongamer\r\n// Description: A tool for helping people learn trig\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nvoid Main()\r\n{\r\n    glClear( 0, 0, 0 ); // Clear screen\r\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe (-1 to 1 mode)\r\n\r\n    timer R0; // Set time to curtime()\r\n    R0 = -R0 * 1;\r\n\r\n    glColor( 255, 255, 255 ); // Set draw color\r\n    glCircle( *orig.x, *orig.y, 0.66, 40 ); // Draw circle (x, y, radius, quality)\r\n    \r\n    glColor( 0, 0, 0 );\r\n    glCircle( *orig.x, *orig.y, 0.64, 40 );\r\n\r\n    // Set the points for the trig\r\n    fcos *cos,R0;\r\n    fsin *sin,R0;\r\n\r\n    *PosR.x = *cos;\r\n    *PosR.x *= 0.65;\r\n    *PosR.x += *orig.x;\r\n    \r\n    *PosR.y = *sin;\r\n    *PosR.y *= 0.65;\r\n    *PosR.y += *orig.y;\r\n\r\n    *PosX.x = *PosR.x;\r\n    \r\n    glLineWidth( 0.01 ); // Set line width\r\n    glFontSize( 24 ); // Set font size\r\n\r\n    // X part of triangle\r\n    glColor( 0, 0, 255 );\r\n    glLine( *orig.x, *orig.y, *PosX.x, *PosX.y ); // Draw line\r\n    glWriteFmt( -0.95, -0.95, sCos ) // Write formatted string\r\n\r\n    // Y part of triangle\r\n    glColor( 255, 0, 0 );\r\n    glLine( *PosR.x, *PosR.y, *PosX.x, *PosX.y );\r\n    *sin *= -1; // Negate\r\n    glWriteFmt( -0.95, -0.85, sSin );\r\n    \r\n    glColor( 255, 255, 255 );\r\n    glLine( *orig.x, *orig.y, *PosR.x, *PosR.y ); // Draw line\r\n    \r\n    glExit(); // Exit\r\n}\r\n\r\nvec2f orig,0,0;\r\nvec2f PosR,0,0;\r\nvec2f PosX,0,0;\r\n\r\nstring sCos,\"Cosine = %f\";\r\nalloc cos;\r\n\r\nstring sSin,\"Sine   = %f\";\r\nalloc sin;\r\n","gpuchip/examples/3d_letter_a.txt":"// Author: Drunkie\r\n// Description: Draws a 3D model of the letter A\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nvoid Main()\r\n{\r\n    glSleep( 40 ); // Sleep for 40 milliseconds (reduces fps lag)\r\n    glClear( 100, 149, 237 ); // Clear screen\r\n    \r\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe to [-1 to 1] mode \r\n    glVertexPipe( GL_VPIPE_XYZTRANSFORM ); // Set vertex pipe to xyz transformation\r\n\r\n    glLightPos( 0, 0, -50 ); // Set the light position\r\n    glLightColor( 255, 255, 255, 1 ); // Set the light color\r\n\r\n    glLookAt(\r\n        0, 0, -2.8, // Camera pos\r\n        0, 0, 0, // Camera target\r\n        0, 1, 0 // Camera up\r\n    ); \r\n    \r\n    // Create variable to hold curtime\r\n    float time;\r\n    timer time;\r\n   \r\n    // Create perspective and matrix transformations\r\n    glPerspective( 30, 1, 1, 20 ); // FOV, ASPECT RATIO, ZNEAR, ZFAR\r\n    glRotate( 0, 1, 0, time ); // AXIS X, Y, Z, ANGLE W\r\n    glTranslate( 0, -0.1, 0, 0 ); // TRANSLATION X, Y, Z\r\n    glScale( 1, 1, 1, 0 ); // SCALE X, Y, Z\r\n\r\n    glEnable( GL_VERTEX_BUFFER ); // Enable vertex buffer \r\n    glEnable( GL_VERTEX_ZSORT ); // Enable Z sorting\r\n    glEnable( GL_VERTEX_LIGHTING ); // Enable vertex lighting\r\n    glEnable( GL_VERTEX_CULLING ); // Enable face culling\r\n    \r\n    // Solid 3D polygon\r\n    glFillMode( GL_FILL_SOLID ); // Set fillmode as solid\r\n    glColor4( 255, 255, 255, 255 ); // Set draw color with alpha\r\n    glPoly3D( vertexBuffer, 30 ); // Draw 3D polygon \r\n    glFlush(); // Flush the vertex buffer to the screen\r\n    \r\n    glExit(); // Exit\r\n}\r\n\r\n// The vertex data for our model\r\nvertexBuffer:\r\ndb 1,1,0; db 0.75,1,0; db 0.25,-1,0;\r\ndb 0.75,1,0; db 0,-1,0; db 0.25,-1,0;\r\ndb -1,1,0; db -0.25,-1,0; db -0.75,1,0;\r\ndb -0.75,1,0; db -0.25,-1,0; db 0,-1,0;\r\ndb 1,1,0.25; db 0.25,-1,0.25; db 0.75,1,0.25;\r\ndb 0.75,1,0.25; db 0.25,-1,0.25; db 0,-1,0.25;\r\ndb -1,1,0.25; db -0.75,1,0.25; db -0.25,-1,0.25;\r\ndb -0.75,1,0.25; db 0,-1,0.25; db -0.25,-1,0.25;\r\ndb 0.25,-1,0; db -0.25,-1,0; db 0.25,-1,0.25;\r\ndb -0.25,-1,0; db -0.25,-1,0.25; db 0.25,-1,0.25;\r\ndb -1,1,0; db -1,1,0.25; db -0.25,-1,0;\r\ndb -1,1,0.25; db -0.25,-1,0.25; db -0.25,-1,0;\r\ndb 1,1,0.25; db 1,1,0; db 0.25,-1,0;\r\ndb 1,1,0.25; db 0.25,-1,0; db 0.25,-1,0.25;\r\ndb -0.75,1,0; db 0,-1,0; db -0.75,1,0.25;\r\ndb -0.75,1,0.25; db 0,-1,0; db 0,-1,0.25;\r\ndb 0.75,1,0; db 0.75,1,0.25; db 0,-1,0;\r\ndb 0.75,1,0.25; db 0,-1,0.25; db 0,-1,0;\r\ndb -0.47,0.25,0; db -0.38,0.01,0; db 0.38,0.01,0;\r\ndb 0.38,0.01,0; db 0.47,0.25,0; db -0.47,0.25,0;\r\ndb -0.47,0.25,0.25; db 0.38,0.01,0.25; db -0.38,0.01,0.25;\r\ndb 0.38,0.01,0.25; db -0.47,0.25,0.25; db 0.47,0.25,0.25;\r\ndb -0.38,0.01,0; db -0.38,0.01,0.25; db 0.38,0.01,0;\r\ndb 0.38,0.01,0; db -0.38,0.01,0.25; db 0.38,0.01,0.25; \r\ndb -0.47,0.25,0; db 0.47,0.25,0; db -0.47,0.25,0.25;\r\ndb -0.47,0.25,0.25; db 0.47,0.25,0; db 0.47,0.25,0.25;\r\ndb -1,1,0; db -0.75,1,0; db -1,1,0.25;\r\ndb -0.75,1,0; db -0.75,1,0.25; db -1,1,0.25;\r\ndb 1,1,0; db 1,1,0.25; db 0.75,1,0;\r\ndb 0.75,1,0; db 1,1,0.25; db 0.75,1,0.25;\r\n","gpuchip/examples/texture.txt":"// Author: Drunkie\r\n// Description: A very simple texture example\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nvoid Main()\r\n{\r\n    glVertexMode( 1 );\r\n    glColor( 255, 255, 255, 255 );\r\n\r\n    glBindTexture( 'brick/brick_model' );\r\n    glColor( 255, 255, 255, 255 );\r\n    glRectWH( 128, 128, 256, 256 );\r\n    \r\n    glExit(); \r\n}\r\n\r\n// ZASM version\r\n\r\n//mov #regVertexMode,1;\r\n//dcolor white;\r\n//dxtexture tex;\r\n//drectwh pos,size;\r\n//dexit;\r\n//color white,255,255,255;\r\n//string tex,'brick/brick_model';\r\n//vec2f pos,128,128;\r\n//vec2f size,256,256;\r\n","gpuchip/examples/foxlogo.txt":"//Fox game console logo (also example on how to work with polygons)\r\n\r\ndclrscr chassis;\r\n\r\ndcolor fox1c;\r\ndvxdata_2f fox1a,16; //16 max!!\r\ndvxdata_2f fox2a,3;\r\ndvxdata_2f fox3a,3;\r\ndvxdata_2f fox4a,3;\r\ndvxdata_2f fox5a,3;\r\ndvxdata_2f fox6a,3;\r\ndvxdata_2f fox7a,6;\r\ndvxdata_2f fox8a,3;\r\n\r\ndcolor fox2c;\r\ndvxdata_2f fox2,4;\r\n\r\ndexit;\r\n\r\n//===========================================\r\ncolor chassis,0,0,0;\r\n\r\ncolor fox1c,60,60,60;\r\ncolor fox2c,100,100,100;\r\n//===========================================\r\nfox1a: //N=16\r\ndb 60,218\r\ndb 62,173\r\ndb 32,36\r\ndb 214,119\r\ndb 268,128\r\ndb 318,168\r\ndb 352,233\r\ndb 494,243\r\ndb 499,254\r\ndb 496,266\r\ndb 478,321\r\ndb 335,374\r\ndb 265,408\r\ndb 223,419\r\ndb 95,430\r\ndb 109,408\r\n\r\nfox2a: //N = 3\r\ndb 109,408\r\ndb 57,432\r\ndb 69,376\r\nfox3a:\r\ndb 69,376\r\ndb 33,394\r\ndb 59,327\r\nfox4a:\r\ndb 59,327\r\ndb 24,348\r\ndb 54,273\r\nfox5a:\r\ndb 54,273\r\ndb 29,286\r\ndb 57,240\r\nfox6a:\r\ndb 57,240\r\ndb 26,245\r\ndb 60,218\r\n\r\nfox7a: //N=6\r\ndb 109,408\r\ndb 69,376\r\ndb 59,327\r\ndb 54,273\r\ndb 57,240\r\ndb 60,218\r\n\r\nfox8a: //N=3\r\ndb 177,150;\r\ndb 269,150;\r\ndb 190,47;\r\n\r\n//===========================================\r\nfox2: //N=4\r\ndb 340,238\r\ndb 286,257\r\ndb 274,203\r\ndb 311,213\r\n//===========================================","gpuchip/examples/table.txt":"// Author: Drunkie\r\n// Description: Draws a table; useful for calendars or spreadsheets!\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nfloat rows = 6;\r\nfloat cols = 5;\r\nfloat sizex = 476;\r\nfloat sizey = 400;\r\nfloat linewidth = 3;\r\n\r\nfloat i, j, day;\r\n\r\nvoid Main()\r\n{\r\n    dentrypoint 0,DrawThread; \r\n    dentrypoint 4,AsyncThread;\r\n    \r\n    *regHWClear = 0\r\n    *regAsyncFreq = 200000;\r\n    *regAsyncClk = 1;\r\n}\r\n\r\nvoid DrawThread()\r\n{\r\n    dexit;\r\n}\r\n\r\nvoid AsyncThread()\r\n{\r\n    glBegin();\r\n    \r\n        glClear( 35, 35, 35 ); // Clear screen color\r\n        \r\n        glColor( 255, 255, 255 ); // Set draw color\r\n        glFont( GL_FONT_ARIAL ); // Set font type\r\n        glFontSize( 36 ); // Set font size\r\n        glWriteString( 16, 6, 'Simple-Calendar 1.0');\r\n        \r\n        glColor( 120, 120, 120 );\r\n        glOffset( 16, 64 ); // Set screen offset\r\n        glRectWH( 0, 0, sizex + linewidth, sizey + linewidth); // Draw rectangle\r\n        \r\n        glFont( GL_FONT_TREBUCHET );\r\n        glFontSize( 14 );\r\n        \r\n        // Calculate rectangle size\r\n        float sx = (sizex / rows) - linewidth;\r\n        float sy = (sizey / cols) - linewidth;\r\n    \r\n        // Loop through rows\r\n        for (i = 0; i < rows; i++)\r\n        {\r\n            // Loop through columns\r\n            for (j = 0; j < cols; j++)\r\n            {\r\n                // Calculate x,y coordinate to draw at\r\n                float x = i * (sizex / rows);\r\n                float y = j * (sizey / cols);\r\n    \r\n                glColor( 200, 200, 200 ); // Set draw color\r\n                glRectWH( x + linewidth, y + linewidth, sx, sy ); // Draw rectangle\r\n                \r\n                glColor( 0, 0, 0 ); // Set draw color\r\n                \r\n                // Write integer to screen\r\n                day = i + (j * rows)\r\n                glWriteInt( x + linewidth + 2, y + linewidth + 2, day + 1 ); \r\n            }\r\n        }\r\n    \r\n    glEnd();\r\n}\r\n\r\n\r\n","gpuchip/examples/bounce.txt":"//////////////////////////////////\r\n//  BOUNCING BALL GPU EXAMPLE   //\r\n//////////////////////////////////\r\ndentrypoint 0,_draw;\t\t// Set draw start entrypoint to \"_draw\"\r\n\t\t\t\t//\r\nrand #ball.x;\t\t\t// Set random ball start point\r\nrand #ball.y;\t\t\t//\r\n\t\t\t\t//\r\ndexit;\t\t\t\t// Exit the initialization routine...\r\n//////////////////////////////////\r\n_draw:\t\t\t\t// Entrypoint for the drawing function\r\n\t\t\t\t//\r\ndcvxpipe 2;\t\t\t// Set coordinate pipe to 2 (to use coordinates 0...1)\r\ndclrscr bg_color;\t\t// Clear screen with background color\r\n\t\t\t\t//\r\ndmuldt eax,#d.x;\t\t// EAX = Direction Vector * Delta (change of coords per frame)\r\nadd #ball.x,eax;\t\t// Move the ball\r\ndmuldt eax,#d.y;\t\t//\r\nadd #ball.y,eax;\t\t//\r\n\t\t\t\t//\r\ncmp #ball.x,0.9;\t\t// Check hits against walls\r\ncge bounce.x;\t\t\t// Call bounce routine...\r\ncmp #ball.x,0.0;\t\t//\r\ncle bounce.x;\t\t\t//\r\n\t\t\t\t//\r\ncmp #ball.y,0.9;\t\t// Bounce on other axis\r\ncge bounce.y;\t\t\t//\r\ncmp #ball.y,0.0;\t\t//\r\ncle bounce.y;\t\t\t//\r\n\t\t\t\t//\r\ndcolor ball_color;\t\t// Set color to color of ball\r\ndrectwh ball,ball_wh;\t\t// Draw the ball\r\n\t\t\t\t//\r\ndsetsize 24;\t\t\t// Set font size\r\ndwrite textpos,text;\r\n\t\t\t\t//\r\ndexit;\t\t\t\t// Exit the draw function\r\n//////////////////////////////////\r\nbounce.x:\t\t\t// Bounce function (change X speed)\r\n  neg #d.x; \t\t\t//\r\n  min #ball.x,0.9;\t\t//\r\n  max #ball.x,0.0;\t\t//\r\nret\t\t\t\t//\r\n\t\t\t\t//\r\nbounce.y:\t\t\t// Bounce function (change Y speed)\r\n  neg #d.y;\t\t\t//\r\n  min #ball.y,0.9;\t\t//\r\n  max #ball.y,0.0;\t\t//\r\nret\t\t\t\t//\r\n//////////////////////////////////\r\n// Data and resources\t\t//\r\n//////////////////////////////////\r\n\t\t\t\t//\r\ncolor ball_color,255,255,255;\t// Ball color (white)\r\ncolor bg_color,   64, 32,128;\t// Background color (neon violet)\r\n\t\t\t\t//\r\nvector2f ball;\t\t\t// Ball position\r\nvector2f ball_wh,0.1,0.1;\t// Ball width/height\r\n\t\t\t\t//\r\nvector2f textpos,0.1,0.1;\t// Text position\r\n\t\t\t\t//\r\nvector2f d,1.0,1.0;\t\t// Movement direction & speed\r\n\t\t\t\t//\r\nstring text,'Bouncing ball!';\t// \"Bouncing ball!\"\r\n//////////////////////////////////","gpuchip/examples/3d_cube.txt":"// Author: Drunkie\r\n// Description: 3D Cube\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nvoid Main()\r\n{\r\n    glClear( 0, 0, 0 ); // Clear screen\r\n    \r\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe to [-1 to 1] mode \r\n    glVertexPipe( GL_VPIPE_XYZTRANSFORM ); // Set vertex pipe to xyz transformation\r\n    \r\n    glLightPos( 0, 0, -20 ); // Set the light position\r\n    glLightColor( 255, 255, 255, 1 ); // Set the light color\r\n\r\n    glLookAt(\r\n        0, 0, -5, // Camera pos\r\n        0, 0, 0, // Camera target\r\n        0, 1, 0 // Camera up\r\n    ); \r\n\r\n    // Create variable to hold curtime\r\n    float time;\r\n    timer time;\r\n\r\n    // Create perspective and matrix transformations\r\n    glPerspective( 30, 1, 1, 20 ); // FOV, ASPECT RATIO, ZNEAR, ZFAR\r\n    glRotate( 1, 1, 0, time ); // AXIS X, Y, Z, ANGLE W\r\n    glTranslate( 0, 0, 0 ); // TRANSLATION X, Y, Z\r\n    glScale( 1, 1, 1 ); // SCALE X, Y, Z\r\n\r\n    glEnable( GL_VERTEX_BUFFER ); // Enable vertex buffer \r\n    glEnable( GL_VERTEX_ZSORT ); // Enable Z sorting\r\n\r\n    // Solid 3D polygon\r\n    glFillMode( GL_FILL_SOLID ); // Set fillmode as solid\r\n    glColor4( 100, 149, 237, 180 ); // Set draw color with alpha\r\n    glPoly3D( vertexBuffer, 12 ); // Draw 3D polygon \r\n    glFlush(); // Flush the vertex buffer to the screen\r\n    \r\n    // Wireframe 3D polygon\r\n    glLineWidth( 1 ); // Set line width\r\n    glFillMode( GL_FILL_WIREFRAME ); // Set fillmode as solid\r\n    glColor4( 255, 255, 255, 255 ); // Set draw color with alpha\r\n    glPoly3D( vertexBuffer, 12 ); // Draw 3D polygon \r\n    glFlush(); // Flush the vertex buffer to the screen\r\n    \r\n    glExit(); // Exit\r\n}\r\n\r\n// The vertex data for our model\r\nvertexBuffer:\r\ndb -1,-1,-1; db 1,-1,-1; db 1,1,-1;\r\ndb -1,-1,-1; db 1,1,-1; db -1,1,-1;\r\ndb 1,-1,1; db -1,-1,1; db 1,1,1;\r\ndb -1,-1,1; db -1,1,1; db 1,1,1;\r\ndb 1,-1,-1; db -1,-1,-1; db 1,-1,1;\r\ndb -1,-1,-1; db -1,-1,1; db 1,-1,1;\r\ndb -1,1,-1; db 1,1,-1; db 1,1,1;\r\ndb -1,1,1; db -1,1,-1; db 1,1,1;\r\ndb -1,-1,-1; db -1,1,-1; db -1,1,1;\r\ndb -1,-1,1; db -1,-1,-1; db -1,1,1;\r\ndb 1,1,-1; db 1,-1,-1; db 1,1,1;\r\ndb 1,-1,-1; db 1,-1,1; db 1,1,1;\r\n","gpuchip/examples/3d_tunnel.txt":"// Author: Drunkie\r\n// Description: Draws a never ending tunnel in 3D!\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nvoid Main()\r\n{\r\n    glSleep( 60 ); // Sleep for 60 milliseconds (reduces fps lag)\r\n    glClear( 0, 0, 0 ); // Clear screen\r\n    \r\n    glCoordPipe( GL_CPIPE_N1_1 ); // Set coordinate pipe to [-1 to 1] mode \r\n    glVertexPipe( GL_VPIPE_XYZTRANSFORM ); // Set vertex pipe to xyz transformation\r\n\r\n    glLightPos( -1, -1, -1 ); // Set the light position\r\n    glLightColor( 255, 255, 255, 1.25 ); // Set the light color\r\n\r\n    glLookAt(\r\n        0, 0, -25, // Camera pos\r\n        0, 0, 0, // Camera target\r\n        0, 1, 0 // Camera up\r\n    ); \r\n\r\n    // Loop and draw 4 models\r\n    for (i = 0; i < 4; i++)\r\n    {\r\n        // Set translations for each model\r\n        timer zTranslate;\r\n        zTranslate *= -16;\r\n        mod zTranslate,16;\r\n        zTranslate += (i * 16);\r\n       \r\n        // Create perspective and matrix transformations\r\n        glPerspective( 8, 1, 0.4, 20 ); // FOV, ASPECT RATIO, ZNEAR, ZFAR\r\n        glRotate( 0, 0, 0, 0 ); // AXIS X, Y, Z, ANGLE W\r\n        glTranslate( 0, 0, zTranslate ); // TRANSLATION X, Y, Z\r\n        glScale( 1.2, 1, 8 ); // SCALE X, Y, Z\r\n    \r\n        glEnable( GL_VERTEX_BUFFER ); // Enable vertex buffer \r\n        glEnable( GL_VERTEX_ZSORT ); // Enable Z sorting\r\n        glEnable( GL_VERTEX_LIGHTING ); // Enable vertex lighting\r\n        glEnable( GL_VERTEX_CULLING ); // Enable face culling\r\n\r\n        // Solid 3D polygon\r\n        glFillMode( GL_FILL_SOLID ); // Set fillmode as solid\r\n        glColor4( 255, 255, 255, 150 ); // Set the draw color with alpha\r\n        glPoly3D( VertexBuffer, 12 ); // Draw 3D polygon\r\n        glFlush(); // Send our vertex buffer to screen\r\n        \r\n        // Wireframe 3D polygon\r\n        glLineWidth( 1 ); // Set line width of wireframe\r\n        glFillMode( GL_FILL_WIREFRAME ); // Set fillmode to wireframe\r\n        glColor4( 255, 255, 255, 255 ); // Set the draw color with alpha\r\n        glPoly3D( vertexBuffer, 8 ); // Draw 3D polygon\r\n        glFlush(); // Send our vertex buffer to screen\r\n    }\r\n\r\n    glExit(); // Exit\r\n}\r\n\r\nfloat i;\r\nfloat zTranslate;\r\n\r\nvertexBuffer:\r\ndb 1,1,-1; db -1,1,-1; db 1,1,1;\r\ndb -1,1,-1; db -1,1,1; db 1,1,1;\r\ndb 1,1,-1; db 1,1,1; db 1,-1,-1;\r\ndb 1,-1,-1; db 1,1,1; db 1,-1,1;\r\ndb -1,1,-1; db -1,-1,-1; db -1,1,1;\r\ndb -1,-1,-1; db -1,-1,1; db -1,1,1; \r\ndb 1,-1,-1; db 1,-1,1; db -1,-1,-1;\r\ndb -1,-1,-1; db 1,-1,1; db -1,-1,1;\r\n","gpuchip/examples/line_graph.txt":"// Author: Drunkie\r\n// Description: A fake lag-o-meter that plots points on a grid\r\n\r\nMain();\r\n\r\n#include <drivers\\drv_gl.txt>\r\n\r\nfloat i;\r\nfloat x, y;\r\nfloat ox = 0, oy = 256;\r\nfloat lines = 10;\r\nfloat lineWidth = 1\r\nfloat frameWidth = 510;\r\nfloat frameHeight = 300;\r\n\r\nvoid Main()\r\n{\r\n    glVertexMode( 1 ); // Enable vertex mode\r\n    glColor( 255, 255, 255 ); // Set draw color\r\n    \r\n    // Set texture as background\r\n    glBindTexture( \"phoenix_storms/lag_sign\" );\r\n    glClearTexture();\r\n    glBindTexture( 0 ); // Discard texture\r\n    \r\n    glFont( GL_FONT_AKBAR ); // Set font type\r\n    glFontSize( 36 ); // Set font size\r\n    glWriteString( 2, 2, \"LAG-O-METER\" ); // Write string to screen\r\n    \r\n    glOffset( lineWidth, 90 ); // Offset the screen coordinates\r\n    \r\n    glColor4( 0, 0, 0, 160 ); // Set draw color with alpha\r\n    glRectWH( 0, 0, frameWidth, frameHeight ); // Draw rectangle\r\n    \r\n    glColor( 255, 255, 255 ); \r\n    glLineWidth( lineWidth ); // Set line width\r\n    glORectWH( 0, 0, frameWidth, frameHeight ); // Draw outlined rectangle\r\n    \r\n    glLineWidth( 1 ); // Set line width to 1\r\n    \r\n    // Loop and make a bunch of connected lines\r\n    for (i = 0; i < lines; i++)\r\n    {\r\n        if (i == 0) {\r\n            ox = 0;\r\n            rand oy;\r\n            oy *= frameHeight;\r\n        }\r\n        else {\r\n            ox = x; oy = y;\r\n        }\r\n        x = ((i+1) / lines) * frameWidth;\r\n        rand y;\r\n        y *= frameHeight;\r\n        glLine( ox, oy, x, y ); // Draw line on graph\r\n    }\r\n    \r\n    glOffset( 0, 0 ); // Set screen offset back to 0,0\r\n    glWriteString( 2, 400, \"INTENSE LAG DETECTED\" );\r\n    \r\n    glExit(); // Exit\r\n}\r\n","gpuchip/examples/mt2.txt":"dcvxpipe 3;\r\nmov #regHWClear,0; //Stop hardware clearing\r\ndsetwidth 0.05;\r\n\r\ntimer EAX;\r\nmov EDX,EAX; sub EDX,#PrevTime; //EDX = Delta time\r\nmov #PrevTime,EAX;\r\n\r\nmov EBP,0.4; //Speed of rotation\r\n\r\nmov ECX,8;\r\nDrawLoop:\r\n  mov EAX,#Angle; mul EAX,1;\r\n  fsin #EndPoint.X,EAX; mul EAX,2;\r\n  fcos #EndPoint.Y,EAX;\r\n\r\n  //HSL coloring\r\n  fsin #HSL.R,EAX; mul #HSL.R,127; add #HSL.R,128; add EAX,1.57;// mul EAX,2;\r\n  fsin #HSL.G,EAX; mul #HSL.G,127; add #HSL.G,128; add EAX,1.57;// mul EAX,2;\r\n  fsin #HSL.B,EAX; mul #HSL.B,127; add #HSL.B,128;\r\n  \r\n  dcolor HSL;\r\n\r\n  //Looks very nice\r\n  dline StartPoint1,EndPoint;\r\n  dline StartPoint2,EndPoint;\r\n  dline StartPoint3,EndPoint;\r\n  dline StartPoint4,EndPoint;\r\n  \r\n  mul EDX,EBP;\r\n  add #Angle,EDX;\r\nloop DrawLoop;\r\n\r\ndexit;\r\n\r\nalloc Angle;\r\nalloc PrevTime;\r\n\r\ncolor HSL;\r\n\r\nvector2f EndPoint,0,0;\r\nvector2f StartPoint0,0,0;\r\nvector2f StartPoint1,1,1;\r\nvector2f StartPoint2,1,-1;\r\nvector2f StartPoint3,-1,-1;\r\nvector2f StartPoint4,-1,1;\r\n","gpuchip/examples/mt3.txt":"//== 3D Graphics begin here ====================================================\r\n  dvxpipe 3;\r\n  dcvxpipe 3;\r\n\r\n  //Calc depth here\r\n  mov #Background.MinDepth,  0.8; //Near distance\r\n  mov #Background.MaxDepth,  6.0; //Far distance\r\n  mov #Background.ShadeStart,1.0;\r\n  mov #Background.DepthStep ,0.3; //Depth step. The lower, the higher quality is\r\n\r\n  timer #Time; mul #Time,3;\r\n\r\n  mov EAX,#Time; mod EAX,#Background.DepthStep;\r\n\r\n  sub #Background.MinDepth,EAX;\r\n  sub #Background.MaxDepth,EAX;\r\n\r\n  //Initialize depth range\r\n  mov  #Background.deltaDepth,#Background.MaxDepth;\r\n  sub  #Background.deltaDepth,#Background.MinDepth;\r\n\r\n  //Compute background stuff\r\n  mov  #Background.ShadeStep,#Background.deltaDepth;\r\n  div  #Background.ShadeStep,#Background.DepthStep;\r\n  frnd #Background.ShadeStep;\r\n  finv #Background.ShadeStep;\r\n  mul  #Background.ShadeStep,#Background.ShadeStepMul;\r\n\r\n  //Brightness too\r\n  mov EAX,#Time; mod EAX,#Background.ShadeStep;\r\n  sub #Background.ShadeStart,EAX;\r\n\r\n  mov #_rect.color.r,200;\r\n  mov #_rect.color.b,200;\r\n\r\n// Uncomment this for trippy camera\r\n//  timer EAX; div EAX,8; fsin EBX,EAX; mul EBX,2;\r\n//  drotatescale EAX,EBX; mul EBX,2;\r\n\r\n  dsetwidth 0.8;\r\n  call Draw.Background; \r\ndexit;\r\n\r\nalloc Time;\r\n\r\n//==============================================================================\r\nDraw.Background:\r\n  //Draw all the rectangles\r\n  mov EAX,#Background.MinDepth; mov ECX,#Background.ShadeStart;\r\n  BackgroundLoop:\r\n    mov EDX,#Time; add EDX,EAX; \r\n    mov EBP,#Time; div EBP,6.28; fcos EBP,EBP;\r\n\r\n    fsin EDI,EDX; mul EDI,EBP; mul EDI,0.8; sub EDI,1;\r\n    mov #_rect.offset.x,EDI;\r\n\r\n    fcos ESI,EDX; mul ESI,EBP; mul ESI,0.4; sub ESI,1;\r\n    mov #_rect.offset.y,ESI;\r\n\r\n    mov EDX,ECX; fpwr EDX,2;\r\n    mov #regZOffset,EAX;\r\n \r\n    dcolor _rect.color; \r\n// Uncomment this for trippy HSL color\r\n//    mov ESI,#Time; add ESI,EAX;\r\n//    fsin #HSL.R,ESI; mul #HSL.R,127; add #HSL.R,128; add ESI,1.57;// mul EAX,2;\r\n//    fsin #HSL.G,ESI; mul #HSL.G,127; add #HSL.G,128; add ESI,1.57;// mul EAX,2;\r\n//    fsin #HSL.B,ESI; mul #HSL.B,127; add #HSL.B,128;\r\n//\r\n//    dcolor HSL;\r\n    dshade EDX;\r\n    dorectwh _rect.offset,_rect.wh;\r\n\r\n    sub ECX,#Background.ShadeStep;\r\n    add EAX,#Background.DepthStep;\r\n\r\n    cmp EAX,#Background.MaxDepth;\r\n    jl BackgroundLoop;\r\nret\r\n\r\n//==============================================================================\r\n//Drawing parameters\r\nscalar Background.MinDepth;\r\nscalar Background.MaxDepth;\r\nscalar Background.deltaDepth;\r\nscalar Background.DepthStep;\r\nscalar Background.ShadeStart;\r\nscalar Background.ShadeStep;\r\nscalar Background.ShadeStepMul,0.5;\r\n\r\ncolor HSL;\r\n\r\n//Generic rectangle\r\nvector2f _rect.offset,-1,-1;\r\nvector2f _rect.wh,2,2;\r\n\r\nvector2f _pad1.offset;\r\nvector2f _pad2.offset;\r\nvector2f _pad.wh;\r\n\r\n//Color scheme\r\ncolor _rect.color, 200,200,200;\r\ncolor _rect.color2,200,200,000;\r\n\r\ncolor _pad1.color, 000,200,000;\r\ncolor _pad2.color, 200,000,000;\r\n","gpuchip/examples/hud_engine.txt":"//mov #65522,1;\r\n//mov #65525,0.66;\r\n//port0 & port1 - engine left/right throttle (0..1)\r\n//port2 & port3 - delta (not used)\r\n\r\n//This displays engine window in PhoenixWings airplane\r\n\r\nmov #65485,16; //set circle quality\r\n\r\ndclrscr hud_border;\r\n\r\ndcolor hud_text;\r\ndcircle hud_engine1gauge,68;\r\ndcircle hud_engine2gauge,68;\r\ndcolor hud_border;\r\ndcircle hud_engine1gauge,64;\r\ndcircle hud_engine2gauge,64;\r\n\r\ndcolor hud_text;\r\ndsetwidth 1;\r\ndline hud_engine1gauge_start,hud_engine1gauge;\r\ndline hud_engine2gauge_start,hud_engine2gauge;\r\n\r\ndsetwidth 2;\r\n\r\n//===\r\nmov eax,port0; mul eax,100;\r\nmul eax,0.1;\r\nmul #left_power,1.9;\r\nadd #left_power,eax;\r\ndiv #left_power,2;\r\n\r\nmov eax,#left_power; div eax,100;\r\nmul eax,6.00;\r\nadd eax,1.57;\r\n\r\ndrotatescale eax,1;\r\ndmove hud_engine1gauge;\r\n\r\ndline gauge_base,gauge_needle;\r\n//==\r\nmov #right_power,#left_power; //comment this and..\r\n//uncomment if your left/right engines are not synchronized\r\n//mov eax,port1; mul eax,100;\r\n//mul eax,0.1;\r\n//mul #right_power,1.9;\r\n//add #right_power,eax;\r\n//div #right_power,2;\r\n\r\n//mov eax,#right_power; div eax,100;\r\n//mul eax,6.00;\r\n//add eax,1.57;\r\n\r\ndrotatescale eax,1;\r\ndmove hud_engine2gauge;\r\n\r\ndline gauge_base,gauge_needle;\r\n//==\r\n\r\n//use this for whatever you wanna\r\n//mov #left_delta,port2; sub #left_delta,7.6; mul #left_delta,10;\r\n//mov #right_delta,port3; sub #right_delta,7.6; mul #right_delta,10;\r\n\r\ndrotatescale 0,1; //reset!\r\ndmove 0;\r\n\r\ndsetfont 4;\r\ndsetsize 28;\r\ndwritefmt hud_text1pos,hud_text1;\r\ndwritefmt hud_text2pos,hud_text2;\r\n\r\ncmp port4,1;\r\ndcolor hud_yellow;\r\nje _nsh;\r\n  dshade 0.25;\r\n_nsh:\r\ndwrite hud_text3pos,hud_text3;\r\ndexit;\r\n\r\nvector2f hud_text1pos,70,212;\r\nvector2f hud_text2pos,310,212;\r\nvector2f hud_text3pos,20,460;\r\n\r\nstring hud_text1,'Left Engine',10,10,'N1 = %i%%',10,'Delta = %i%%';\r\nalloc left_power; alloc left_delta;\r\nstring hud_text2,'Right Engine',10,10,'N1 = %i%%',10,'Delta = %i%%';\r\nalloc right_power; alloc right_delta;\r\nstring hud_text3,'<FASTEN SEAT BELTS>';\r\n\r\nvector2f hud_engine1gauge,128,128;\r\nvector2f hud_engine1gauge_start,128,64;\r\n\r\nvector2f hud_engine2gauge,384,128;\r\nvector2f hud_engine2gauge_start,384,64;\r\n\r\nvector2f gauge_base,0,0;\r\nvector2f gauge_needle,0,-48;\r\n\r\ncolor hud_text,64,255,64;\r\ncolor hud_yellow,255,255,64;\r\ncolor hud_border,30,30,30;\r\n","gpuchip/examples/plasma.txt":"//Plasma fractals\r\n//Converted by dlb from http://bocoup.com/processing-js/docs/index.php?page=Plasma%20Fractals\r\n//Which was converted by F1LT3R @ Hyper-Metrix.com from original at http://www.ic.sunysb.edu/Stu/jseyster/plasma/\r\n\r\nmov #regHWClear,0; //Stop GPU clearing itself\r\n\r\ndentrypoint 0,_draw; //Set the entry point for the draw loop\r\ndentrypoint 4,_async; //Set the enty point for the async loop\r\n\r\nmov #regAsyncFreq,2000000; //Make async run as fast as it can\r\nmov #regAsyncClk,1; //Start async\r\n\r\ndexit; //End init\r\n_draw: //Start draw\r\ndexit; //End draw\r\n\r\n//Setup variables\r\ncolor col;\r\nvec2f pos;\r\nvec2f size;\r\nfloat gridSize, edge1, edge2, edge3, edge4, midPoint, newWidth, newHeight, width, height, noise;\r\n\r\n_async: //Enter async\r\n\r\nmain(); //Run main function\r\n\r\nwhile(1){idle} //Infinatly loop\r\n\r\nvoid main(){ //Main function\r\n    dsetbuf_spr; //Use sprite buffer\r\n    \r\n    setColor(255,255,255); //Set the colour to white\r\n    rect(0,0,512,512); //Draw a large rectangle\r\n\r\n    gridSize = 4; //How big each rectangle will be\r\n    width = 512; //GPU Width\r\n    height = 512; //GPU Height\r\n    noise = 5; //How noisy it will be\r\n    \r\n    //Give initial corner values\r\n    R1 = random(1);\r\n    R2 = random(1);\r\n    R3 = random(1);\r\n    R4 = random(1);\r\n    \r\n    plasma(0,0,width,height,R1,R2,R3,R4) //Start recursive function\r\n}\r\n\r\nvoid plasma(float x, y, width, height, c1, c2, c3, c4){ //Plasma function\r\n    \r\n    //Setup local variables\r\n    float edge1, edge2, edge3, edge4, midPoint;\r\n    \r\n    //Work out the size of the next segments\r\n    float newWidth = width / 2;\r\n    float newHeight = height / 2;\r\n    \r\n    if((width > gridSize)||(height > gridSize)){ //If it is still bigger than the rectangle size\r\n        \r\n        midPoint = (c1 + c2 + c3 + c4) / 4 + displace(newWidth + newHeight); //Randomly change the midpoint\r\n        \r\n        //Calculate edges by averaging the corners\r\n        edge1 = (c1 + c2) / 2;      \r\n        edge2 = (c2 + c3) / 2;  \r\n        edge3 = (c3 + c4) / 2;  \r\n        edge4 = (c4 + c1) / 2; \r\n        \r\n        //Make sure it doesn't displace too far\r\n        max midPoint,0;\r\n        min midPoint,1;\r\n        \r\n        //Run on the newly calculated segments\r\n        plasma(x, y, newWidth, newHeight, c1, edge1, midPoint, edge4);\r\n        plasma(x + newWidth, y, newWidth, newHeight, edge1, c2, edge2, midPoint);  \r\n        plasma(x + newWidth, y + newHeight, newWidth, newHeight, midPoint, edge2, c3, edge3);  \r\n        plasma(x, y + newHeight, newWidth, newHeight, edge4, midPoint, edge3, c4);\r\n    }else{ //Woo! It's the right size\r\n        float c = (c1 + c2 + c3 + c4) / 4; //Average the corners\r\n        \r\n        float grey = c*255; //Multiply the corners by 255 to get a valid color\r\n        \r\n        setColor(grey,grey,grey); //Set the color to your new color based on the \"height\"\r\n        rect(x,y,gridSize,gridSize); //Draw your rectangle\r\n    }\r\n}\r\n\r\nfloat displace(float num){ //Displace function, it just works\r\n    float m = num / (width + height) * (1/noise);   \r\n    R1 = random(1);  \r\n    return (R1-0.5) * m;  \r\n}\r\n\r\nfloat random(float x){ //C version of the ASM rand opcode\r\n    preserve EAX;\r\n    rand EAX;\r\n    return EAX*x;\r\n}\r\n\r\nvoid setColor(float r,float g,float b){ //C version of the dcolor opcode\r\n    mov #col.r,r;\r\n    mov #col.g,g;\r\n    mov #col.b,b;\r\n    \r\n    dcolor col;\r\n}\r\n\r\nvoid rect(float x, float y, float width, float height){ //C version of the drectwh opcode\r\n    mov #pos.x,x;\r\n    mov #pos.y,y;\r\n    \r\n    mov #size.x,width;\r\n    mov #size.y,height;\r\n    \r\n    drectwh pos, size;\r\n    dswap; //dswap to make it show since we're drawing to the sprite buffer\r\n}"},"gpuchip/lib/":{"gpuchip/lib/drivers/":{"gpuchip/lib/drivers/drv_gl.txt":"// [Author] - Drunkie\r\n// [Description] - A graphics driver that provides C-style functions for GPU\r\n// [Documentation] - http://goo.gl/DHhYb\r\n\r\n\r\n#define GL\r\n\r\n// Font\r\n#define GL_FONT_LUCIDA_CONSOLE 0\r\n#define GL_FONT_COURIER_NEW 1\r\n#define GL_FONT_TREBUCHET 2\r\n#define GL_FONT_ARIAL 3\r\n#define GL_FONT_TIMES_NEW_ROMAN 4\r\n#define GL_FONT_COOLVETICA 5\r\n#define GL_FONT_AKBAR 6\r\n#define GL_FONT_CSD 7\r\n\r\n// Buffer\r\n#define GL_BUFFER_FRONT 0\r\n#define GL_BUFFER_BACK 1\r\n#define GL_BUFFER_SPRITE 1\r\n#define GL_BUFFER_VERTEX 2\r\n\r\n// Coordinate pipe\r\n#define GL_CPIPE_DIRECT 0\r\n#define GL_CPIPE_RESOLUTION 1\r\n#define GL_CPIPE_0_1 2\r\n#define GL_CPIPE_N1_1 3\r\n#define GL_CPIPE_N256_256 4\r\n\r\n// Vertex pipe\r\n#define GL_VPIPE_XY 0\r\n#define GL_VPIPE_YZ 1\r\n#define GL_VPIPE_XZ 2\r\n#define GL_VPIPE_XYZPROJ 3\r\n#define GL_VPIPE_XYTRANSFORM 4\r\n#define GL_VPIPE_XYZTRANSFORM 5\r\n\r\n// denable / ddisable\r\n#define GL_VERTEX_BUFFER 0\r\n#define GL_VERTEX_ZSORT 1\r\n#define GL_VERTEX_LIGHTING 2\r\n#define GL_VERTEX_CULLING 3\r\n#define GL_VERTEX_DCULLING 4\r\n#define GL_VERTEX_TEXTURING 5\r\n\r\n// Fillmode\r\n#define GL_FILL_SOLID 0\r\n#define GL_FILL_WIREFRAME 1\r\n#define GL_FILL_TEXTURE 2\r\n\r\n// Cullmode\r\n#define GL_CULL_FRONT 0\r\n#define GL_CULL_BACK 1\r\n\r\n// Lightmode\r\n#define GL_LIGHT_FRONT 1\r\n#define GL_LIGHT_BACK -1\r\n\r\n// Horizontal font\r\n#define GL_ALIGN_LEFT 0\r\n#define GL_ALIGN_CENTER 1\r\n#define GL_ALIGN_RIGHT 2\r\n\r\n// Vertical font\r\n#define GL_VALIGN_TOP 0\r\n#define GL_VALIGN_MIDDLE 1\r\n#define GL_VALIGN_BOTTOM 2\r\n\r\n// Compatibility\r\n#define glSetTexture glBindTexture\r\n#define glWriteFmt glWriteFormat\r\n#define glFontHAlign glFontAlign\r\n\r\n\r\n// Clear\r\nvoid glClear( float r, float g, float b ) {\r\n    mov #GL_BG.r,r; mov #GL_BG.g,g; mov #GL_BG.b,b; mov #GL_BG.a,255;\r\n    dclrscr GL_BG;\r\n}\r\nvoid glClear4( float r, float g, float b, float a ) {\r\n    mov #GL_BG.r,r; mov #GL_BG.g,g; mov #GL_BG.b,b; mov #GL_BG.a,a;\r\n    dclrscr GL_BG;\r\n}\r\nvoid glClearTexture() {\r\n    dclrtex;\r\n}\r\nvoid glHWClear( float n ) {\r\n    mov #regHWClear,n;\r\n}\r\n\r\n// Color\r\nvoid glColor( float r, float g, float b ) {\r\n    mov #GL_FG.r,r; mov #GL_FG.g,g; mov #GL_FG.b,b; mov #GL_FG.a,255;\r\n    dcolor GL_FG;\r\n}\r\nvoid glColor4( float r, float g, float b, float a ) {\r\n    mov #GL_FG.r,r; mov #GL_FG.g,g; mov #GL_FG.b,b; mov #GL_FG.a,a;\r\n    dcolor GL_FG;\r\n}\r\nvoid glBrightness( float r, float g, float b, float a ) {\r\n    mov #regBrightnessR,r;\r\n    mov #regBrightnessG,g;\r\n    mov #regBrightnessB,b;\r\n    mov #regBrightnessW,a;\r\n}\r\nvoid glContrast( float r, float g, float b, float a ) {\r\n    mov #regContrastR,r;\r\n    mov #regContrastG,g;\r\n    mov #regContrastB,b;\r\n    mov #regContrastW,a;\r\n}\r\nvoid glShade( float n ) {\r\n    dshade n;\r\n}\r\nvoid glShadeNorm( float n ) {\r\n    dshadenorm n;\r\n}\r\n\r\n// Texture\r\nvoid glBindTexture( char* str ) {\r\n    dxtexture str;\r\n}\r\nvoid glTexture( float id ) {\r\n    dtexture id;\r\n}\r\nvoid glTextureSize( float n ) {\r\n    mov #regTexSize,n;\r\n}\r\nvoid glTextureDataPtr( float n ) {\r\n    mov #regTexDataPtr,n;\r\n}\r\nvoid glTextureDataSize( float n ) {\r\n    mov #regTexDataSz,n;\r\n}\r\nvoid glTextureRotation( float n ) {\r\n    mov #regTexRotation,n;\r\n}\r\nvoid glTextureScale( float n ) {\r\n    mov #regTexScale,n;\r\n}\r\nvoid glTextureCenterUV( float u, float v ) {\r\n    mov #regTexCenterU,u;\r\n    mov #regTexCenterV,v;\r\n}\r\nvoid glTextureOffsetUV( float u, float v ) {\r\n    mov #regTexOffsetU,u;\r\n    mov #regTexOffsetV,v;\r\n}\r\n\r\n// Frame\r\nvoid glSleep( float ms ) {\r\n    div ms,1000;\r\n    timer #GL_CURTIME; \r\n    sub #GL_CURTIME,#GL_TIMESTAMP;\r\n    if (*GL_CURTIME <= ms) {\r\n        mov #regHWClear,0;\r\n        dexit;\r\n    }\r\n    timer #GL_TIMESTAMP;   \r\n}\r\nvoid glExit() {\r\n    dexit;\r\n}\r\n\r\n// Pipeline\r\nvoid glCoordPipe( float c ) {\r\n    dcpipe c;\r\n}\r\nvoid glVertexPipe( float v ) {\r\n    dvxpipe v;\r\n}\r\n\r\n// Hardware\r\nvoid glReset( float n ) {\r\n    mov #regReset,n;\r\n}\r\nvoid glHalt( float n ) {\r\n    mov #regHalt,n;\r\n}\r\nvoid glRAMReset( float n ) {\r\n    mov #regRAMReset,n;\r\n}\r\nvoid glHScale( float n ) {\r\n    mov #regHScale,n;\r\n}\r\nvoid glVScale( float n ) {\r\n    mov #regVScale,n;\r\n}\r\nvoid glHWScale( float n ) {\r\n    mov #regHWScale,n;\r\n}\r\nvoid glHWRotate( float n ) {\r\n    mov #regRotation,n;\r\n}\r\n\r\n// Offset\r\nvoid glOffset( float x, float y ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    dmove GL_V1;\r\n}\r\nfloat glOffsetX() {\r\n    preserve eax;\r\n    mov eax,#regOffsetX;\r\n}\r\nfloat glOffsetY() {\r\n    preserve eax;\r\n    mov eax,#regOffsetY;\r\n}\r\nvoid glCenter( float x, float y ) {\r\n    mov #regCenterX,x;\r\n    mov #regCenterY,y;\r\n}\r\n\r\n// Async\r\nvoid glAsyncReset( float n ) {\r\n    mov #regAsyncReset,n;\r\n}\r\nvoid glAsyncClk( float n ) {\r\n    mov #regAsyncClk,n;\r\n}\r\nvoid glAsyncFreq( float n ) {\r\n    mov #regAsyncFreq,n;\r\n}\r\nvoid glEntryPoint( float idx, float ptr ) {\r\n    dentrypoint idx,ptr;\r\n}\r\nvoid glBegin() {\r\n    dbegin;\r\n}\r\nvoid glEnd() {\r\n    dend;\r\n}\r\nvoid glSwap() {\r\n    dswap;\r\n}\r\nvoid glSync() {\r\n    dvsync;\r\n}\r\n\r\n// Cursor\r\nvoid glCursor( float n ) {\r\n    mov #regCursor,n;\r\n}\r\nfloat glCursorX() {\r\n    preserve eax;\r\n    mov eax,#regCursorX;\r\n}\r\nfloat glCursorY() {\r\n    preserve eax;\r\n    mov eax,#regCursorY;\r\n}\r\n\r\n// Circle\r\nvoid glCircleQuality( float n ) {\r\n    mov #regCircleQuality,n;\r\n}\r\nvoid glCircleStart( float n ) {\r\n    mov #regCircleStart,n;\r\n}\r\nvoid glCircleEnd( float n ) {\r\n    mov #regCircleEnd,n;\r\n}\r\n\r\n// Screen scaling\r\nvoid glScreenScale( float n ) {\r\n    mov #regScale,n;\r\n}\r\nvoid glScreenScaleX( float x ) {\r\n    mov #regScaleX,x;\r\n}\r\nvoid glScreenScaleY( float y ) {\r\n    mov #regScaleY,y;\r\n}\r\n\r\n// 2D graphics\r\nvoid glCircle( float x, float y, float radius ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    dcircle GL_V1,radius;\r\n}\r\nvoid glRect( float x, float y, float dx, float dy ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    mov #GL_V2.x,dx; mov #GL_V2.y,dy;\r\n    drect GL_V1,GL_V2;\r\n}\r\nvoid glRectWH( float x, float y, float w, float h ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    mov #GL_V2.x,w; mov #GL_V2.y,h;\r\n    drectwh GL_V1,GL_V2;\r\n}\r\nvoid glORect( float x, float y, float dx, float dy ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    mov #GL_V2.x,dx; mov #GL_V2.y,dy;\r\n    dorect GL_V1,GL_V2;\r\n}\r\nvoid glORectWH( float x, float y, float w, float h ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    mov #GL_V2.x,w; mov #GL_V2.y,h;\r\n    dorectwh GL_V1,GL_V2;\r\n}\r\nvoid glPixel( float x, float y ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    dpixel GL_V1,GL_FG;\r\n}\r\nvoid glLine( float x, float y, float dx, float dy ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    mov #GL_V2.x,dx; mov #GL_V2.y,dy;\r\n    dline GL_V1,GL_V2;\r\n}\r\nvoid glLineWidth( float w ) {\r\n    dsetwidth w;\r\n}\r\nvoid glPoly2D( float* buffer, float count ) {\r\n    dvxdata_2f buffer,count;\r\n}\r\n\r\n\r\n// Text\r\nvoid glFont( float id ) {\r\n    dsetfont id;\r\n}\r\nvoid glFontAlign( float n ) {\r\n    mov #regFontHalign,n;\r\n}\r\nvoid glFontVAlign( float n ) {\r\n    mov #regFontValign,n;\r\n}\r\nvoid glFontSize( float n ) {\r\n    dsetsize n;\r\n}\r\nfloat glTextWidth( char* str ) {\r\n    preserve eax;\r\n    dtextwidth eax,str;\r\n}\r\nfloat glTextHeight( char* str ) {\r\n    preserve eax;\r\n    dtextheight eax,str;\r\n}\r\nvoid glWriteString( float x, float y, char* str ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    dwrite GL_V1,str;\r\n}\r\nvoid glWriteFloat( float x, float y, float n ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    dwritef GL_V1,n;\r\n}\r\nvoid glWriteInt( float x, float y, float n ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    dwritei GL_V1,n;\r\n}\r\nvoid glWriteFormat( float x, float y, char* str ) {\r\n    mov #GL_V1.x,x; mov #GL_V1.y,y;\r\n    dwritefmt GL_V1,str;\r\n}\r\nfloat glParamList() {\r\n    preserve eax;\r\n    mov eax,#regParamList;\r\n}\r\n\r\n\r\n// 3D graphics\r\nvoid glPoly3D( float* buffer, float count ) {\r\n    \r\n    if (*GL_MUPDATE == 1) {\r\n        mov #GL_MUPDATE,0;\r\n        mrotate GL_MROTATEMATRIX,GL_VROTATE;\r\n        mtranslate GL_MTRANSLATEMATRIX,GL_VTRANSLATE;\r\n        mscale GL_MSCALEMATRIX,GL_VSCALE;\r\n        mmov GL_MMODELMATRIX,GL_MTRANSLATEMATRIX;\r\n        mmul GL_MMODELMATRIX,GL_MROTATEMATRIX;\r\n        mmul GL_MMODELMATRIX,GL_MSCALEMATRIX;\r\n        mmov GL_MMODELVIEWMATRIX,GL_MVIEWMATRIX;\r\n        mmul GL_MMODELVIEWMATRIX,GL_MMODELMATRIX;\r\n        mload GL_MMODELVIEWMATRIX; \r\n        mloadproj GL_MPROJECTIONMATRIX;\r\n    }\r\n    \r\n    if (*GL_FILLMODE == GL_FILL_SOLID) {\r\n        dvxdata_3f buffer,count;\r\n    }\r\n    else if (*GL_FILLMODE == GL_FILL_WIREFRAME) {\r\n        dvxdata_3f_wf buffer,count;\r\n    }\r\n    else if (*GL_FILLMODE == GL_FILL_TEXTURE) {\r\n        dvxdata_3f_tex buffer,count\r\n    }\r\n}\r\nvoid glFlush() {\r\n    dvxflush;\r\n}\r\nvoid glEnable( float n ) {\r\n    denable n;\r\n}\r\nvoid glDisable( float n ) {\r\n    ddisable n;\r\n}\r\nvoid glLightPos( float x, float y, float z ) {\r\n    mov #GL_LIGHTPOS.x,x; mov #GL_LIGHTPOS.y,y; mov #GL_LIGHTPOS.z,z;\r\n    dsetlight 0,GL_LIGHTDATA;\r\n}\r\nvoid glLightColor( float r, float g, float b, float a ) {\r\n    mov #GL_LIGHTCOL.r,r; mov #GL_LIGHTCOL.g,g;\r\n    mov #GL_LIGHTCOL.b,b; mov #GL_LIGHTCOL.a,a;\r\n    dsetlight 0,GL_LIGHTDATA;\r\n}\r\nvoid glFillMode( float n ) {\r\n    mov #GL_FILLMODE,n;\r\n}\r\nvoid glLookAt( float x, float y, float z, float tx, float ty, float tz, float ux, float uy, float uz ) {\r\n    mov #GL_VLOOKAT_POS.x,x; mov #GL_VLOOKAT_POS.y,y; mov #GL_VLOOKAT_POS.z,z;\r\n    mov #GL_VLOOKAT_TARG.x,tx; mov #GL_VLOOKAT_TARG.y,ty; mov #GL_VLOOKAT_TARG.z,tz;\r\n    mov #GL_VLOOKAT_UP.x,ux; mov #GL_VLOOKAT_UP.y,uy; mov #GL_VLOOKAT_UP.z,uz;\r\n    mlookat GL_MVIEWMATRIX,GL_VLOOKAT;\r\n    mov #GL_MUPDATE,1;\r\n}\r\nvoid glPerspective( float fov, float asp, float znear, float zfar ) {\r\n    mov #GL_VPERSPECTIVE.x,fov; mov #GL_VPERSPECTIVE.y,asp;\r\n    mov #GL_VPERSPECTIVE.z,znear; mov #GL_VPERSPECTIVE.w,zfar;\r\n    mperspective GL_MPROJECTIONMATRIX,GL_VPERSPECTIVE;\r\n    mov #GL_MUPDATE,1;\r\n}\r\nvoid glRotate( float x, float y, float z, float w ) {\r\n    mov #GL_VROTATE.x,x; mov #GL_VROTATE.y,y; mov #GL_VROTATE.z,z; mov #GL_VROTATE.w,w;      \r\n    mov #GL_MUPDATE,1;\r\n}\r\nvoid glTranslate( float x, float y, float z ) {\r\n    mov #GL_VTRANSLATE.x,x; mov #GL_VTRANSLATE.y,y; mov #GL_VTRANSLATE.z,z;\r\n    mov #GL_MUPDATE,1;\r\n}\r\nvoid glScale( float x, float y, float z ) {\r\n    mov #GL_VSCALE.x,x; mov #GL_VSCALE.y,y; mov #GL_VSCALE.z,z;\r\n    mov #GL_MUPDATE,1;\r\n}\r\nvoid glZOffset( float n ) {\r\n    mov #regZOffset,n;\r\n}\r\nvoid glCullDistance( float n ) {\r\n    mov #regCullDistance,n;\r\n}\r\nvoid glCullMode( float n ) {\r\n    mov #regCullMode,n;\r\n}\r\nvoid glLightMode( float n ) {\r\n    mov #regLightMode,n;\r\n}\r\nvoid glVertexArray( float n ) {\r\n    mov #regVertexArray,n;\r\n}\r\n\r\n// Other\r\nvoid glVertexMode( float n ) {\r\n    mov #regVertexMode,n;\r\n}\r\nvoid glSetRenderTarget( float n ) {\r\n    if (n == GL_BUFFER_FRONT) {\r\n        dsetbuf_fbo;\r\n    }\r\n    else if (n == GL_BUFFER_BACK) {\r\n        dsetbuf_spr;\r\n    }\r\n    else if (n == GL_BUFFER_VERTEX) {\r\n        dsetbuf_vx;\r\n    }\r\n}\r\nfloat glIndex() {\r\n    preserve eax;\r\n    mov eax,#regIndex;\r\n}\r\n\r\n\r\n// Allocated variables for GL\r\ncolor GL_FG,255,255,255;\r\ncolor GL_BG;\r\nvec4f GL_V1;\r\nvec4f GL_V2;\r\n\r\nalloc GL_TIMESTAMP;\r\nalloc GL_CURTIME;\r\nalloc GL_FILLMODE;\r\n\r\nGL_LIGHTDATA:\r\nvec4f GL_LIGHTPOS,0,0,-10;\r\ncolor GL_LIGHTCOL,255,255,255,1;\r\n\r\nGL_VLOOKAT:\r\nvec3f GL_VLOOKAT_POS,0,0,-10;\r\nvec3f GL_VLOOKAT_TARG,0,0,0;\r\nvec3f GL_VLOOKAT_UP,0,1,0;\r\n\r\nmatrix GL_MROTATEMATRIX;\r\nmatrix GL_MTRANSLATEMATRIX;\r\nmatrix GL_MSCALEMATRIX;\r\nmatrix GL_MPROJECTIONMATRIX;\r\nmatrix GL_MVIEWMATRIX;\r\nmatrix GL_MMODELMATRIX;\r\nmatrix GL_MMODELVIEWMATRIX;\r\nalloc GL_MUPDATE,1;\r\n\r\nvec4f GL_VROTATE;\r\nvec4f GL_VTRANSLATE;\r\nvec4f GL_VPERSPECTIVE;\r\nvec4f GL_VSCALE,1,1,1,0;\r\n\r\n\r\n","gpuchip/lib/drivers/drv_gl_toolkit.txt":"#ifndef GL\r\n#include <drivers\\drv_gl.txt>\r\n#endif\r\n\r\n#ifndef GLT\r\n\r\n#define GLT\r\n#define GLT_MAX_TRIANGLES 32\r\n\r\nfloat __GLT_VERTBUFF[(GLT_MAX_TRIANGLES * 3) * 3];\r\nfloat __GLT_VERTCNT = 0;\r\n\r\nvoid gltVertex(float x, float y, float z)\r\n{\r\n    if ((__GLT_VERTCNT / 3) >= GLT_MAX_TRIANGLES)\r\n    \treturn;\r\n    \r\n    float* ptr = __GLT_VERTBUFF;\r\n    ptr += (__GLT_VERTCNT * 3);\r\n    \r\n    *ptr = x;\r\n    *(++ptr) = y;\r\n    *(++ptr) = z;\r\n    \r\n    __GLT_VERTCNT++;\r\n}\r\n\r\nvoid gltTriangle(float x1, float y1, float z1,\r\n                 float x2, float y2, float z2,\r\n                 float x3, float y3, float z3)\r\n{\r\n    gltVertex(x1, y1, z1);\r\n    gltVertex(x2, y2, z2);\r\n    gltVertex(x3, y3, z3);\r\n}\r\n\r\nvoid gltQuad(float tlx, float tly, float tlz,\r\n             float trx, float try, float trz,\r\n             float brx, float bry, float brz,\r\n             float blx, float bly, float blz)\r\n{\r\n    gltTriangle(\r\n        trx, try, trz,\r\n        tlx, tly, tlz,\r\n        blx, bly, blz\r\n    );\r\n    \r\n    gltTriangle(\r\n        brx, bry, brz,\r\n        trx, try, trz,\r\n        blx, bly, blz\r\n    );\r\n}\r\n\r\nvoid gltCube(float cex, float cey, float cez, float size)\r\n{\r\n    float s2 = size / 2;\r\n    \r\n    gltQuad(\r\n        cex - s2, cey + s2, cez - s2,\r\n        cex + s2, cey + s2, cez - s2,\r\n        cex + s2, cey - s2, cez - s2,\r\n        cex - s2, cey - s2, cez - s2\r\n    );\r\n    \r\n    gltQuad(\r\n        cex + s2, cey + s2, cez + s2,\r\n        cex - s2, cey + s2, cez + s2,\r\n        cex - s2, cey - s2, cez + s2,\r\n        cex + s2, cey - s2, cez + s2\r\n    );\r\n    \r\n    gltQuad(\r\n        cex - s2, cey + s2, cez + s2,\r\n        cex - s2, cey + s2, cez - s2,\r\n        cex - s2, cey - s2, cez - s2,\r\n        cex - s2, cey - s2, cez + s2\r\n    );\r\n    \r\n    gltQuad(\r\n        cex + s2, cey + s2, cez - s2,\r\n        cex + s2, cey + s2, cez + s2,\r\n        cex + s2, cey - s2, cez + s2,\r\n        cex + s2, cey - s2, cez - s2\r\n    );\r\n    \r\n    gltQuad(\r\n        cex - s2, cey + s2, cez + s2,\r\n        cex + s2, cey + s2, cez + s2,\r\n        cex + s2, cey + s2, cez - s2,\r\n        cex - s2, cey + s2, cez - s2\r\n    );\r\n    \r\n    gltQuad(\r\n        cex - s2, cey - s2, cez - s2,\r\n        cex + s2, cey - s2, cez - s2,\r\n        cex + s2, cey - s2, cez + s2,\r\n        cex - s2, cey - s2, cez + s2\r\n    );\r\n}\r\n\r\nvoid gltClearBuffer()\r\n{\r\n    __GLT_VERTCNT = 0;\r\n}\r\n\r\nvoid gltFlushBuffer()\r\n{\r\n    if (__GLT_VERTCNT <= 3)\r\n        return;\r\n        \r\n    float vcnt = __GLT_VERTCNT;\r\n    float tcnt = (vcnt / 3) - (vcnt % 3);\r\n    \r\n    if (tcnt > GLT_MAX_TRIANGLES)\r\n        tcnt = GLT_MAX_TRIANGLES;\r\n    \r\n    glPoly3D(__GLT_VERTBUFF, tcnt);\r\n    glFlush();\r\n}\r\n\r\n#endif\r\n"}}},"spuchip/examples/":{"spuchip/examples/mario_theme.txt":"// Author: Jasongamer\r\n// Song: Mario Underwater Theme\r\n\r\n// Set track wave to channel 0 and start\r\nwset 0,trackwave;\r\nchwave 0,0;\r\nchvolume 0,0.2;\r\nchstart 0;\r\n\r\n// Set track wave to channel 1 and start\r\nwset 1,trackwave;\r\nchwave 1,1;\r\nchvolume 1,0.2;\r\nchstart 1;\r\n\r\n// Set bass wave to channel 2 and start\r\nwset 2,basswave;\r\nchwave 2,1;\r\nchvolume 2,0.3;\r\nchstart 2;\r\n\r\n// Get track length\r\ntracklen = strlen(trackA);\r\n\r\nvoid main()\r\n{\r\n    // Tempo\r\n    if ((i > 120) && (i <= 230))\r\n        tempo( 1000 );\r\n    else\r\n        tempo( 864 );\r\n\r\n    // Track A\r\n    note = 2;\r\n    fpwr note,(trackA[i]/12);\r\n    note /= 100;\r\n    chpitch 0,note;\r\n    \r\n    // Track B\r\n    note = 2;\r\n    fpwr note,(trackB[i]/12);\r\n    note /= 100;\r\n    chpitch 1,note;\r\n    \r\n    // Bass\r\n    note = 2;\r\n    fpwr note,(bass[i]/12);\r\n    note /= 100;\r\n    chpitch 2,note;\r\n    \r\n    // Index\r\n    i++; mod i,tracklen;\r\n    \r\n    // Repeat\r\n    jmp main;\r\n}\r\n\r\n// Accurate tempo function for beats-per-minute\r\nvoid tempo( float bpm )\r\n{\r\n    timer timestamp;\r\n    while ((time - timestamp) < (60 / bpm)) { timer time; }\r\n}\r\n\r\n// Returns the length of a string\r\nfloat strlen(char* str)\r\n{\r\n  char* strptr = str;\r\n  while (*strptr++);\r\n  return (strptr - str);\r\n}\r\n\r\nfloat note, i;\r\nfloat tracklen;\r\nfloat time, timestamp;\r\n\r\nstring trackwave,\"synth/square.wav\";\r\nstring basswave,\"synth/tri.wav\";\r\n\r\ntrackA:\r\n\r\n// Intro\r\ndb 73,73,73,73, 75,75,75,75, 77,77,77,77,   78,78,78,78, 80,80,80,80, 81,81,81,81;\r\ndb 82,-1,82,-1, 82,82,82,-1, 82,82,82,-1,   82,82,82,82, 82,82,82,-1, -1,-1,78,78;\r\n\r\n// Part 1\r\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   86,86,86,86, 86,86,86,86, 86,86,86,-1;\r\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   -1,-1,78,78, 80,80,82,82, 83,83,85,85;\r\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   86,86,86,86, 86,86,86,-1, 88,88,88,-1;\r\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,78,78;\r\ndb 85,85,85,85, 85,85,85,85, 85,85,85,-1,   84,84,84,84, 84,84,84,84, 84,84,84,-1;\r\ndb 85,85,85,85, 85,85,85,85, 85,85,85,-1,   -1,-1,78,78, 80,80,82,82, 83,83,84,84;\r\ndb 85,85,85,85, 85,85,85,85, 85,85,85,-1,   78,78,78,78, 78,78,78,-1, 88,88,88,-1;\r\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,78,78;\r\n\r\n// Part 2\r\ndb 90,90,90,90, 90,90,90,90, 90,90,90,-1,   90,90,90,90, 90,90,90,90, 90,90,90,-1;\r\ndb 90,90,90,90, 90,90,90,90, 90,90,90,-1,   90,90,90,-1, 92,92,-1,-1, -1,-1,90,90;\r\ndb 88,88,88,88, 88,88,88,88, 88,88,88,-1,   88,88,88,88, 88,88,88,88, 88,88,88,-1; \r\ndb 88,88,88,88, 88,88,88,88, 88,88,88,-1,   88,88,88,-1, 90,90,-1,-1, -1,-1,88,88; \r\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   80,80,80,-1, 82,82,82,-1, 88,88,88,-1; \r\ndb 87,-1,87,-1, 87,87,87,87, 87,-1,82,82,   83,83,83,83, 83,83,83,83, 83,83,83,-1;\r\n\r\ndb 0; // End string\r\n\r\ntrackB:\r\n\r\n// Intro\r\ndb 73,73,73,73, 72,72,72,72, 71,71,71,71,   70,70,70,70, 71,71,71,71, 72,72,72,72; \r\ndb 73,-1,73,-1, 73,73,73,-1, 75,75,75,-1,   76,76,76,76, 76,76,76,-1, -1,-1,-1,-1;\r\n\r\n// Part 1\r\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   77,77,77,77, 77,77,77,77, 77,77,77,-1;\r\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\r\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   77,77,77,77, 77,77,77,-1, 80,80,80,-1;\r\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\r\ndb 76,76,76,76, 76,76,76,76, 76,76,76,-1,   75,75,75,75, 75,75,75,75, 75,75,75,-1;\r\ndb 76,76,76,76, 76,76,76,76, 76,76,76,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\r\ndb 76,76,76,76, 76,76,76,76, 76,76,76,-1,   70,70,70,70, 70,70,70,-1, 80,80,80,-1;\r\ndb 78,78,78,78, 78,78,78,78, 78,78,78,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\r\n\r\n// Part 2\r\ndb 87,87,87,87, 87,87,87,87, 87,87,87,-1,   85,85,85,85, 85,85,85,85, 85,85,85,-1;\r\ndb 84,84,84,84, 84,84,84,84, 84,84,84,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\r\ndb 85,85,85,85, 85,85,85,85, 85,85,85,-1,   84,84,84,84, 84,84,84,84, 84,84,84,-1;\r\ndb 83,83,83,83, 83,83,83,83, 83,83,83,-1,   -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\r\ndb 71,71,71,71, 71,71,71,71, 71,71,71,-1,   76,76,76,-1, 78,78,78,-1, 82,82,82,-1;\r\ndb 82,-1,82,-1, 82,82,82,-1, -1,-1,76,76,   75,75,75,75, 75,75,75,75, 75,75,75,-1;\r\n\r\ndb 0; // End string\r\n\r\nbass: \r\n\r\n// Intro\r\ndb -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1;\r\ndb -1,-1,-1,-1, -1,-1,-1,-1, 66,66,66,-1, 66,66,66,66, 66,66,66,66, 66,66,66,-1;\r\n\r\n// Part 1\r\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 58,58,58,-1, 66,66,66,-1, 70,70,70,-1;\r\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 63,63,63,-1, 66,66,66,-1, 71,71,71,-1;\r\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 58,58,58,-1, 66,66,66,-1, 70,70,70,-1;\r\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 63,63,63,-1, 66,66,66,-1, 71,71,71,-1;\r\ndb 61,61,61,-1, 66,66,66,-1, 70,70,70,-1, 60,60,60,-1, 65,65,65,-1, 69,69,69,-1;\r\ndb 61,61,61,-1, 66,66,66,-1, 70,70,70,-1, 58,58,58,-1, 66,66,66,-1, 70,70,70,-1;\r\ndb 61,61,61,-1, 66,66,66,-1, 70,70,70,-1, 58,58,58,-1, 66,66,66,-1, 70,70,70,-1;\r\ndb 59,59,59,-1, 66,66,66,-1, 71,71,71,-1, 54,54,54,-1, 66,66,66,-1, 71,71,71,-1;\r\n\r\n// Part 2\r\ndb 59,59,59,-1, 66,66,66,-1, 75,75,75,-1, 58,58,58,-1, 66,66,66,-1, 73,73,73,-1;\r\ndb 57,57,57,-1, 66,66,66,-1, 72,72,72,-1, 60,60,60,-1, 66,66,66,-1, 75,75,75,-1;\r\ndb 61,61,61,-1, 68,68,68,-1, 76,76,76,-1, 60,60,60,-1, 68,68,68,-1, 76,76,76,-1;\r\ndb 59,59,59,-1, 68,68,68,-1, 76,76,76,-1, 58,58,58,-1, 66,66,66,-1, 76,76,76,-1;\r\ndb 47,47,47,-1, 66,66,66,-1, 75,75,75,-1, 54,54,54,-1, 66,66,66,-1, 66,66,66,-1;\r\ndb 64,-1,64,-1, 64,64,64,-1, -1,-1,58,58, 59,59,59,59, 59,59,59,59, 59,59,59,-1;\r\n\r\ndb 0; // End string\r\n\r\n","spuchip/examples/beatbox.txt":"wset 4,inst1;\r\nchwave 1,4;\r\nchpitch 1,2.55;\r\n\r\nchwave 2,0;\r\nchvolume 2,0.5;\r\nchstart 2;\r\nchpitch 2,0;\r\n\r\nmainloop:\r\n  timer r0;\r\n  mul r0,6;\r\n  mov r1,r0;\r\n\r\n  fint r0;\r\n  mod r0,16;\r\n  add r0,0;\r\n  mod r1,1;\r\n  currentTick = r0;\r\n  currentTickTime = r1;\r\n\r\n  instr1 = patternData1[currentTick];\r\n  instr2 = patternData2[currentTick];\r\n  instr3 = patternData3[currentTick];\r\n\r\n  if ((pinstr1 == 0) && (instr1 == 1)) {\r\n    chstart 0;\r\n  } else {\r\n    chstop 0;\r\n  }\r\n\r\n  if ((pinstr2 == 0) && (instr2 == 1)) {\r\n    chstart 1;\r\n  } else {\r\n    chstop 1;\r\n  }\r\n\r\n  mov r0,currentTickTime; neg r0; add r0,1; fpwr r0,4;\r\n  mul r0,0.6; // add r0,0.64;\r\n  chpitch 0,r0;\r\n\r\n  mov r0,instr3;\r\n  mul r0,0.1;\r\n  add r0,0.2;\r\n  chpitch 2,r0;\r\njmp mainloop;\r\n\r\nfloat currentTick,currentTickTime;\r\nfloat instr1,instr2,instr3;\r\nfloat pinstr1,pinstr2;\r\n\r\npatternData1: db 1,1,0,0, 1,0,0,0, 1,0,0,1, 0,1,0,0, 1,1,0,0, 1,1,0,0, 1,1,0,1, 1,0,1,0;\r\npatternData2: db 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0;\r\npatternData3: db 0,1,0,2, 0,1,2,2, 0,0,1,1, 1,2,1,2, 2,2,1,2, 2,2,1,1, 1,1,0,0, 0,0,1,2;\r\n\r\nstring inst1,\"synth/pink_noise.wav\";\r\n"},"prevhash.txt":"4243da411622f01ce0b720176ba036a752129755\r\n","adv_duplicator/":{"adv_duplicator/wireman.txt":"[Info]\r\nType:AdvDupe File\r\nCreator:\"Maso\"\r\nDate:05/01/11\r\nDescription:\"none\"\r\nEntities:8\r\nConstraints:31\r\n[More Information]\r\nFileVersion:0.84\r\nAdvDupeVersion:1.85\r\nAdvDupeToolVersion:1.9\r\nAdvDupeSharedVersion:1.72\r\nSerialiserVersion:1.4\r\nWireVersion:2435 (EXPORTED)\r\nTime:05:28 AM\r\nHead:188\r\nHoldAngle:0,-157.54,0\r\nHoldPos:59.9271,1.05281,0.728333\r\nStartPos:9809.35,-670.248,8.03125\r\n[Save]\r\nEntities:19BB9E48{;}197CE8F0{Y:12=T:18F29AA0;}1B88A158{;}1B74B110{;}1917E4C8{Y:3=A:89.5833,-6.53094,180.117;Y:4=V:-31.7705,2.54797,46.933;Y:6=B:f;}H19B2B218{N:189=T:1B72EC10;N:242=T:18FC0620;N:197=T:1C085C88;N:266=T:19014EC0;N:191=T:1AC73D38;N:188=T:1C22F948;N:268=T:168D3A80;N:267=T:18F4D870;}1B74B0E0{Y:28=T:1B74B110;}1C9B2C68{N:0=T:1C9B2C98;}1ADB32B8{N:0=T:1BE418D0;}1C085C88{Y:3=A:89.5833,-6.53094,-179.883;Y:4=V:-31.7705,2.54797,46.933;Y:5=N:0;Y:7=T:1917E498;Y:9=Y:8;Y:2=Y:17;}18FC0620{Y:2=Y:14;Y:3=A:0.000332517,173.62,-0.000518799;Y:4=V:-16.4063,0.997742,45.4449;Y:5=N:0;Y:7=T:19F37CE8;Y:9=Y:8;Y:13=T:1D7F8B78;}19AB7118{T:1B88A128;T:1B88A158;}18F29AA0{Y:11=Y:10;}19F37D18{Y:3=A:0.000332517,173.62,359.999;Y:4=V:-16.4063,0.997742,45.4449;Y:6=B:t;}19BB9DE8{T:19BB9E18;T:19BB9E48;}192FF7B8{Y:3=A:-0.294498,-6.38357,180.031;Y:4=V:-15.6973,14.6041,44.1504;Y:6=B:f;}19F37CE8{N:0=T:19F37D18;}1B7B2298{Y:15=N:50;}1A5D0438{Y:29=T:1B74B0E0;}1B88A128{;}18EC6B08{N:0=T:18EC6B38;}1917E498{N:0=T:1917E4C8;}18F4D870{Y:3=A:-0.00354703,173.62,-0.000518799;Y:4=V:-7.63672,-10.4395,81.5085;Y:5=N:0;Y:7=T:18EC6B08;Y:9=Y:8;Y:2=Y:18;}18EC6B38{Y:3=A:-0.00354703,173.62,359.999;Y:4=V:-7.63672,-10.4395,81.5085;Y:6=B:f;}168D3A80{Y:2=Y:1;Y:3=A:-0.356212,-6.67777,-179.956;Y:4=V:-17.5264,-12.4753,44.1833;Y:5=N:0;Y:7=T:169A4588;Y:9=Y:8;Y:13=T:17F0D510;}192FF788{N:0=T:192FF7B8;}169A45B8{Y:3=A:-0.356212,-6.67777,180.044;Y:4=V:-17.5264,-12.4753,44.1833;Y:6=B:f;}169A4588{N:0=T:169A45B8;}19014EC0{Y:3=A:-0.00345482,173.62,-0.000518799;Y:4=V:-5.36621,9.82532,81.5081;Y:5=N:0;Y:7=T:1C9B2C68;Y:9=Y:8;Y:2=Y:18;}17F0D510{Y:12=T:1BB4F010;}1BB4F010{Y:11=Y:10;}16AA7618{N:0=T:16AA7648;}1D7F8B78{Y:16=T:1B7B2298;}1C22F948{Y:7=T:1ADB32B8;Y:9=Y:20;Y:3=A:89.6399,-5.53999,1.19965;Y:21=T:19BB9DE8;Y:22=T:19AB7118;Y:24=Y:23;Y:4=V:-1.22168,-0.923706,59.9212;Y:2=Y:25;Y:27=Y:26;Y:13=T:1A5D0438;Y:30=T:18FB23A0;Y:5=N:0;}1AC73D38{Y:3=A:-0.0362574,81.479,-91.1042;Y:4=V:-31.6016,2.5882,72.2405;Y:5=N:0;Y:7=T:16AA7618;Y:9=Y:8;Y:2=Y:19;}19BB9E18{;}1BE418D0{Y:3=A:89.6399,-5.53999,1.19965;Y:4=V:-1.22168,-0.923706,59.9212;Y:6=B:f;}18FB23A0{;}1C9B2C98{Y:3=A:-0.00345482,173.62,359.999;Y:4=V:-5.36621,9.82532,81.5081;Y:6=B:f;}1B72EC10{Y:2=Y:1;Y:3=A:-0.294498,-6.38357,-179.969;Y:4=V:-15.6973,14.6041,44.1504;Y:5=N:0;Y:7=T:192FF788;Y:9=Y:8;Y:13=T:197CE8F0;}16AA7648{Y:3=A:-0.0362574,81.479,268.896;Y:4=V:-31.6016,2.5882,72.2405;Y:6=B:f;}\r\nConstraints:1A790460{Y:31=N:242;Y:32=N:0;}1926A480{Y:33=T:18FACDC8;Y:35=Y:34;}1BF200A0{Y:33=T:1AE0AAB0;Y:35=Y:34;}1A3475D0{Y:36=B:t;Y:37=N:0;Y:33=T:1A347600;Y:38=B:t;Y:35=Y:39;}18463E50{Y:33=T:18463EA8;Y:35=Y:34;}1990A7D8{T:1990A838;T:19174B18;}1A3F1790{T:1959F900;T:1959F930;}1BF8D7F8{Y:33=T:1B876C20;Y:35=Y:34;}19264F50{Y:31=N:191;Y:32=N:0;}1C27D280{Y:33=T:1C27D2D8;Y:35=Y:34;}18FACDC8{T:18FACE28;T:1BF20048;}1AA19F28{Y:31=N:197;Y:32=N:0;}0DC038F0{Y:31=N:191;Y:32=N:0;}1990A838{Y:31=N:242;Y:32=N:0;}1BF20048{Y:31=N:267;Y:32=N:0;}1CD1CE98{Y:33=T:1990A7D8;Y:35=Y:34;}191EE670{Y:31=N:189;Y:32=N:0;}18FACE28{Y:31=N:266;Y:32=N:0;}1A330960{Y:33=T:1A4427A8;Y:35=Y:34;}1AA19F58{Y:31=N:191;Y:32=N:0;}1D6991E8{Y:31=N:268;Y:32=N:0;}1959F900{Y:31=N:267;Y:32=N:0;}175D6690{Y:33=T:175D66E8;Y:35=Y:34;}175D66E8{T:1768DC48;T:1768DC78;}1768DC48{Y:31=N:197;Y:32=N:0;}19B3B058{Y:31=N:189;Y:32=N:0;}19256CE0{Y:31=N:191;Y:32=N:0;}19174B18{Y:31=N:268;Y:32=N:0;}1B6D74A0{Y:31=N:268;Y:32=N:0;}1923B508{Y:33=T:1923B560;Y:35=Y:34;}18D92A30{Y:31=N:242;Y:32=N:0;}1BBE43E0{Y:31=N:189;Y:32=N:0;}197AEE78{Y:31=N:242;Y:32=N:0;}19F08CC8{Y:33=T:1A4319B8;Y:35=Y:34;}194C60C0{Y:31=N:242;Y:32=N:0;}18463EA8{T:1BBE43E0;T:1BBE4410;}1D699188{T:1D6991E8;T:1C36CF98;}19174B48{Y:33=T:1D699188;Y:35=Y:34;}18A09CD8{Y:31=N:189;Y:32=N:0;}19B3B088{S:\"Ang\"=A:-0.459895,-134.973,180.006;Y:35=Y:40;Y:33=T:18A09C78;Y:41=N:100000;}185934F8{Y:31=N:268;Y:32=N:0;}18B99330{Y:31=N:197;Y:32=N:0;}1916DDB0{Y:31=N:242;Y:32=N:0;}1A6D2950{Y:31=N:189;Y:32=N:0;}1A330930{Y:31=N:242;Y:32=N:0;}1959F930{Y:31=N:191;Y:32=N:0;}191EE540{Y:33=T:191EE570;Y:35=Y:34;}1AC56190{Y:31=N:267;Y:32=N:0;}1B876C20{T:1B876C80;T:19B3B058;}19319C60{Y:31=N:267;Y:32=N:0;}1A4319B8{T:18DE61D0;T:18DE6200;}19C5D490{Y:33=T:1916DD50;Y:35=Y:34;}1AE0AAB0{T:1B6D74A0;T:1B6D74D0;}1A3F1738{Y:33=T:1A3F1790;Y:35=Y:34;}1B6D74D0{Y:31=N:266;Y:32=N:0;}192A1980{Y:31=N:242;Y:32=N:0;}1912FFF8{Y:31=N:189;Y:32=N:0;}1BBE4410{Y:31=N:266;Y:32=N:0;}191E4AD0{T:1A6D2950;T:1A6D2980;}18F2BAC0{Y:33=T:1912FF98;Y:35=Y:34;}19434350{Y:31=N:242;Y:32=N:0;}1916DD50{T:1916DDB0;T:18B99330;}1D5A5A10{Y:31=N:189;Y:32=N:0;}19E7E308{Y:31=N:191;Y:32=N:0;}19576620{Y:31=N:242;Y:32=N:0;}1A6D2980{Y:31=N:268;Y:32=N:0;}192ADB98{Y:31=N:242;Y:32=N:0;}191EE570{T:1D5A5A10;T:1D5A5A40;}1C39D2C8{T:1A790430;T:1A790460;}1A347600{T:192ADB68;T:192ADB98;}194C60F0{Y:31=N:189;Y:32=N:0;}1BF21E50{T:19E7E2D8;T:19E7E308;}190AFDC0{Y:33=T:18D929D0;Y:35=Y:34;}19EB4CA8{T:194C60C0;T:194C60F0;}17509828{T:192A1950;T:192A1980;}19EB4C78{Y:33=T:19EB4CA8;Y:35=Y:39;Y:37=N:0;}18DE6200{Y:31=N:266;Y:32=N:0;}18B99388{Y:33=T:1C39D2C8;Y:35=Y:39;Y:37=N:0;}19CF3F20{Y:33=T:1AC56130;Y:35=Y:39;Y:37=N:0;}19BA27B0{Y:31=N:267;Y:32=N:0;}1AC56130{T:1AC56190;T:1A330930;}175097D0{Y:33=T:17509828;Y:35=Y:39;Y:37=N:0;}1A429D00{T:19C5D460;}19E7E2D8{Y:31=N:266;Y:32=N:0;}1A429CA8{S:\"Ang\"=A:-0.355103,-135.268,180.042;Y:35=Y:40;Y:33=T:1A429D00;Y:41=N:100000;}19319CB8{Y:33=T:191E4AD0;Y:35=Y:34;}19BA2780{Y:31=N:197;Y:32=N:0;}1923B560{T:19BA2780;T:19BA27B0;}1926A450{Y:31=N:266;Y:32=N:0;}19529848{Y:31=N:197;Y:32=N:0;}194342F0{T:19434350;T:185934F8;}1A442808{Y:31=N:242;Y:32=N:0;}195297E8{T:19529848;T:1926A450;}19264EF0{T:19264F50;T:197AEE78;}1927D100{T:1AA19F28;T:1AA19F58;}1912FF98{T:1912FFF8;T:0DC038F0;}18D929D0{T:18D92A30;T:19256CE0;}197AEED0{Y:33=T:1927D100;Y:35=Y:34;}1C36CF98{Y:31=N:191;Y:32=N:0;}18DE61D0{Y:31=N:242;Y:32=N:0;}19C5D460{Y:31=N:268;Y:32=N:0;}18A09C78{T:18A09CD8;}1A98C800{Y:33=T:195297E8;Y:35=Y:34;}192A1950{Y:31=N:266;Y:32=N:0;}1C27D2D8{T:191EE640;T:191EE670;}191EE640{Y:31=N:197;Y:32=N:0;}1A347920{Y:31=N:268;Y:32=N:0;}1956EB60{T:19576620;}192ADB68{Y:31=N:188;Y:32=N:0;}18B391F0{S:\"Ang\"=A:-0.000781828,45.0297,360;Y:35=Y:40;Y:33=T:1956EB60;Y:41=N:100000;}0DC03920{Y:33=T:19264EF0;Y:35=Y:39;Y:37=N:0;}19256D38{Y:33=T:1BF21E50;Y:35=Y:34;}1A3478C0{T:1A347920;T:19319C60;}1B876C80{Y:31=N:242;Y:32=N:0;}18593528{Y:33=T:1A3478C0;Y:35=Y:34;}18B39198{Y:31=N:267;Y:32=N:0;}1D5A5A40{Y:31=N:267;Y:32=N:0;}1A4427A8{T:1A442808;T:18B39198;}1A790430{Y:31=N:197;Y:32=N:0;}19BF1458{Y:33=T:194342F0;Y:35=Y:39;Y:37=N:0;}H1969BED8{T:1A330960;T:19174B48;T:1BF8D7F8;T:1A3475D0;T:19319CB8;T:18B391F0;T:19CF3F20;T:1A429CA8;T:18B99388;T:1CD1CE98;T:1926A480;T:1C27D280;T:19256D38;T:175097D0;T:18593528;T:19BF1458;T:1A3F1738;T:19F08CC8;T:197AEED0;T:18463E50;T:1A98C800;T:1923B508;T:19EB4C78;T:191EE540;T:0DC03920;T:18F2BAC0;T:1BF200A0;T:19C5D490;T:19B3B088;T:190AFDC0;T:175D6690;}1768DC78{Y:31=N:268;Y:32=N:0;}\r\n[Dict]\r\n1:\"models/cyborgmatt/capacitor_large.mdl\"\r\n2:\"Model\"\r\n3:\"LocalAngle\"\r\n4:\"LocalPos\"\r\n5:\"Skin\"\r\n6:\"Frozen\"\r\n7:\"PhysicsObjects\"\r\n8:\"prop_physics\"\r\n9:\"Class\"\r\n10:\"beer/wiremod/gate_wirelogo\"\r\n11:\"MaterialOverride\"\r\n12:\"material\"\r\n13:\"EntityMods\"\r\n14:\"models/bull/various/subwoofer.mdl\"\r\n15:\"Mass\"\r\n16:\"mass\"\r\n17:\"models/bull/gates/microcontroller1.mdl\"\r\n18:\"models/bull/various/speaker.mdl\"\r\n19:\"models/bull/gates/resistor.mdl\"\r\n20:\"gmod_wire_expression2\"\r\n21:\"_outputs\"\r\n22:\"_inputs\"\r\n23:\"Wireman\"\r\n24:\"_name\"\r\n25:\"models/bull/gates/processor.mdl\"\r\n26:\"@name Wireman�@inputs �@outputs �@persist �@trigger ��if(first()|duped()) {�    entity():soundPlay(0,0,�npc/zombie_poison/pz_breathe_loop2.wav�)�}�interval(500)�entity():isWeldedTo():applyForce(vec(0,0,-25000))�\"\r\n27:\"_original\"\r\n28:\"Wires\"\r\n29:\"WireDupeInfo\"\r\n30:\"_vars\"\r\n31:\"Index\"\r\n32:\"Bone\"\r\n33:\"Entity\"\r\n34:\"NoCollide\"\r\n35:\"Type\"\r\n36:\"nocollide\"\r\n37:\"forcelimit\"\r\n38:\"deleteonbreak\"\r\n39:\"Weld\"\r\n40:\"Keepupright\"\r\n41:\"angularlimit\"\r\nSaved:291"},"cpuchip/":{"cpuchip/examples/":{"cpuchip/examples/udh_test.txt":"//------------------------------------------------------------------------------\r\n// Universal Device Host driver test application\r\n//------------------------------------------------------------------------------\r\n#pragma CRT ZCRT\r\n\r\n//Include drivers for console screen and device host\r\n#include <drivers\\drv_udh.txt>\r\n#include <drivers\\drv_cscr.txt>\r\n\r\nvoid main() {\r\n  float i;\r\n  udhSetBusAddress(65536);\r\n  \r\n  cscrInitialize(0);\r\n\r\n  udhQueryDevices();\r\n\r\n  for (i = 0; i < MAX_CONSOLE_SCREENS; i++) {\r\n    cscrSelect(i);\r\n    cscrSetActive(1);\r\n    cscrClear();\r\n    \r\n    cscrSetCursor(0,0);\r\n    cscrPrintLine(\"Screen \",930);\r\n    cscrPrintNumber(i,930); \r\n  }\r\n\r\n  cscrSelect(0);\r\n  cscrSetCursor(0,2);\r\n  cscrPrintLine(\"UDH driver test\\n\",039);\r\n  for (i = 0; i < 8; i++) {\r\n    cscrPrintLine(\"DEVICE \",999);\r\n    cscrPrintNumber(i,999);\r\n    cscrPrintLine(\": \",999);\r\n    cscrPrintLine(udhGetDeviceName(i),666);\r\n    cscrPrintLine(\"\\n\",999);\r\n  }\r\n}\r\n","cpuchip/examples/helloworld.txt":"//Wired Hello World!\r\n//Connect CPU membus input to console screen\r\n//Connect CPUs CLK input to button (toggle)\r\n//Notice how you can store your \r\n//subroutines/calls in DATA area\r\njmp _code;\r\nmessage:\r\n  db 'Hello World!',0;\r\nWriteString: //ESI - String pointer, EDX - Param\r\n  mov eax,65536;\r\n  AWriteLoop:\r\n    cmp #esi,0; //Terminate on char 0\r\n    je AEnd;\r\n    mov #eax,#esi; //Output char\r\n    inc eax;\r\n    mov #eax,edx; //Output char param\r\n    inc eax;\r\n    inc esi;\r\n  jmp AWriteLoop;\r\n  AEnd:\r\nret //Return from call\r\n\r\n_code:\r\n  mov esi,message;\r\n  mov edx,000999; //White foreground on black background\r\n  call WriteString;\r\n\r\n//More about colors:\r\n//Lower 3 digits are foreground, \r\n//and higher 3 digits are background\r\n//Each of 3 digits shows amount of\r\n//RED, GREEN, and BLUE (in order)\r\n//Each color has 10 shades - from 0 to 9\r\n//\r\n//For example, 999044 will be dark yellow (044) on\r\n//a white background (999)\r\n//\r\n//Experiment with colors!\r\n//\r\n//Also, the 7th digit (if its not equal to 0) will\r\n//cause the character to blink by changing foreground and\r\n//background places (actual data in memory wont change)\r\n"},"cpuchip/lib/":{"cpuchip/lib/drivers/":{"cpuchip/lib/drivers/drv_udh.txt":"//------------------------------------------------------------------------------\r\n// ZCPU standard library and drivers set              (C) 2011 by Black Phoenix\r\n//\r\n// Universal device host driver. Only supports 8 devices right now\r\n//------------------------------------------------------------------------------\r\n\r\n#define UDH_DRIVER\r\n\r\n//Maximum number of devices supported\r\n#define MAX_UDH_DEVICES 8\r\n\r\n//Address range of a single device\r\n#define MAX_UDH_ADDRESS_RANGE 4*1024\r\n\r\n//Maximum number of drivers that may register with UDH\r\n#define MAX_UDH_DRIVERS 8\r\n\r\n//Device name/string data\r\nstring udhDeviceString0,\"None\";\r\nstring udhDeviceString1,\"Unknown\";\r\nstring udhDeviceString2,\"Extended bus\";\r\nstring udhDeviceString3,\"Address bus\";\r\nstring udhDeviceString4,\"Zyelios CPU\";\r\nstring udhDeviceString5,\"Zyelios GPU\";\r\nstring udhDeviceString6,\"Zyelios SPU\";\r\nstring udhDeviceString7,\"Flash EEPROM\";\r\nstring udhDeviceString8,\"ROM\";\r\nstring udhDeviceString9,\"Data bus\";\r\nstring udhDeviceString10,\"CD Ray\";\r\nstring udhDeviceString11,\"Console screen\";\r\nstring udhDeviceString12,\"Digital screen\";\r\nstring udhDeviceString13,\"Data plug\";\r\nstring udhDeviceString14,\"Data socket\";\r\nstring udhDeviceString15,\"Keyboard\";\r\nstring udhDeviceString16,\"Oscilloscope\";\r\nstring udhDeviceString17,\"Sound emitter\";\r\nstring udhDeviceString18,\"Constant value\";\r\nstring udhDeviceString19,\"Data port\";\r\nstring udhDeviceString20,\"RAM\";\r\nudhDeviceName: \r\n  db udhDeviceString0, udhDeviceString1, udhDeviceString2;\r\n  db udhDeviceString3, udhDeviceString4, udhDeviceString5;\r\n  db udhDeviceString6, udhDeviceString7, udhDeviceString8;\r\n  db udhDeviceString9, udhDeviceString10,udhDeviceString11;\r\n  db udhDeviceString12,udhDeviceString13,udhDeviceString14;\r\n  db udhDeviceString15,udhDeviceString16,udhDeviceString17;\r\n  db udhDeviceString18,udhDeviceString19,udhDeviceString20;\r\n\r\n//Extended bus offset\r\nchar* udhBusOffset;\r\n\r\n//List of callbacks to call when querying devices\r\nvoid* udhQueryCallback[MAX_UDH_DRIVERS];\r\nfloat udhQueryCallbackCount = 0;\r\n\r\nfloat udhSetBusAddress(char* extOffset) {\r\n  udhBusOffset = extOffset;\r\n  udhQueryDevices();\r\n}\r\n\r\nvoid udhQueryDevices() {\r\n  float i;\r\n\r\n  //Run the query\r\n  udhBusOffset[16] = 32+MAX_UDH_DEVICES;\r\n  udhBusOffset[17] = 1;  \r\n\r\n  //Reconfigure all devices\r\n  //FIXME: only supports single extended bus right now\r\n  for (i = 0; i < 8; i++) {\r\n    udhBusOffset[i*2+0] = (4*1024)*i;\r\n    udhBusOffset[i*2+1] = (4*1024)*i+((4*1024)-1);\r\n  }\r\n\r\n  //Update all drivers\r\n  for (i = 0; i < udhQueryCallbackCount; i++) {\r\n    void* functionPtr = udhQueryCallback[i];\r\n    functionPtr();\r\n  }\r\n}\r\n\r\nvoid udhRegisterDriver(void* queryDeviceFunction) {\r\n  udhQueryCallback[udhQueryCallbackCount] = queryDeviceFunction;\r\n  if (udhQueryCallbackCount < MAX_UDH_DRIVERS) udhQueryCallbackCount++;\r\n}\r\n\r\nfloat udhGetDeviceType(float busIndex) {\r\n  return udhBusOffset[32+busIndex];\r\n}\r\n\r\nfloat udhGetDeviceOffset(float busIndex) {\r\n  return 65536+32+MAX_UDH_DEVICES+udhBusOffset[busIndex*2];\r\n}\r\n\r\nchar* udhGetDeviceName(float busIndex) {\r\n  float deviceType = udhGetDeviceType(busIndex);\r\n  if ((deviceType >= 0) && (deviceType <= 20)) {\r\n    return udhDeviceName[deviceType];  \r\n  } else {\r\n    return udhDeviceName[1];\r\n  }\r\n}\r\n\r\nvoid udhSetDeviceOffsetSize(float busIndex, char* offst, char* size) {\r\n  udhBusOffset[busIndex*2+0] = offst;\r\n  udhBusOffset[busIndex*2+1] = offst+size-1;\r\n}\r\n\r\nfloat udhGetNumDevices() {\r\n  return MAX_UDH_DEVICES;   \r\n}\r\n\r\nfloat udhGetDevices(float type, float maxCount, char* deviceList) {\r\n  float i,devPtr,n;\r\n  \r\n  devPtr = deviceList;\r\n  n = 0;\r\n  for (i = 0; i < MAX_UDH_DEVICES; i++) {\r\n    if ((udhGetDeviceType(i) == type) && (n < maxCount)) {\r\n      n++;\r\n      *devPtr++ = i; \r\n    }\r\n  }\r\n\r\n  return n;\r\n}","cpuchip/lib/drivers/drv_cscr.txt":"//------------------------------------------------------------------------------\r\n// ZCPU standard library and drivers set              (C) 2011 by Black Phoenix\r\n//\r\n// UDH-enabled console screen highspeed driver\r\n//------------------------------------------------------------------------------\r\n\r\n//Define to check if console screen driver is available\r\n#define CSCR_DRIVER\r\n\r\n//Maximum number of console screens supported\r\n#define MAX_CONSOLE_SCREENS 8\r\n\r\n//Console screen registers\r\n#define CURSOR_RATE       2043\r\n#define CURSOR_SIZE       2044\r\n#define CURSOR_POSITION   2045\r\n#define CURSOR_VISIBLE    2046\r\n#define LOW_SHIFT_COL     2031\r\n#define HIGH_SHIFT_COL    2032\r\n#define LOW_SHIFT_ROW     2033\r\n#define HIGH_SHIFT_ROW    2034\r\n#define SHIFT_ROWS        2038\r\n#define SHIFT_CELLS       2037\r\n#define CLEAR_SCREEN      2041\r\n#define BACKGROUND_COLOR  2042\r\n#define SCREEN_ACTIVE     2047\r\n#define SCREEN_ROTATION   2024\r\n#define SCREEN_BRIGHTNESS 2036\r\n\r\n//Driver data\r\nchar* cscrOffsets[MAX_CONSOLE_SCREENS];\r\nfloat cscrDevices[MAX_CONSOLE_SCREENS];\r\nchar* cscrCharacterPointer[MAX_CONSOLE_SCREENS];\r\nfloat cscrSelectedScreen;\r\n\r\n#ifdef UDH_DRIVER\r\n//Update console screen offsets\r\nvoid cscrUDHQueryFunction() {\r\n  float i,n;\r\n  n = udhGetDevices(11,MAX_CONSOLE_SCREENS,cscrDevices);    \r\n  for (i = 0; i < n; i++) {\r\n    cscrOffsets[i] = udhGetDeviceOffset(cscrDevices[i]);\r\n  }\r\n}\r\n#endif\r\n\r\n//Initialize console screen driver. screenOffset may be 0 if using UDH\r\nvoid cscrInitialize(char* screenOffset) {\r\n  float i;\r\n\r\n  for (i = 0; i < MAX_CONSOLE_SCREENS; i++) {\r\n    cscrOffsets[i] = screenOffset;\r\n  }\r\n\r\n#ifdef UDH_DRIVER\r\n    if (!screenOffset) {\r\n      udhRegisterDriver(cscrUDHQueryFunction);\r\n      cscrUDHQueryFunction();\r\n    }\r\n#endif\r\n  cscrSelectedScreen = 0;\r\n}\r\n\r\nfloat cscrPresent(float screen) {\r\n  return cscrOffsets[cscrSelectedScreen] != 0;\r\n}\r\n\r\nvoid cscrSelect(float screen) {\r\n  cscrSelectedScreen = screen;\r\n  max cscrSelectedScreen,0;\r\n  min cscrSelectedScreen,MAX_CONSOLE_SCREENS;\r\n}\r\n\r\nvoid cscrSetActive(float clk) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n  *(cscrOffsets[cscrSelectedScreen]+SCREEN_ACTIVE) = clk;\r\n}\r\n\r\nvoid cscrClear() {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n  *(cscrOffsets[cscrSelectedScreen]+CLEAR_SCREEN) = 1;\r\n  cscrCharacterPointer[cscrSelectedScreen] = 0;\r\n}\r\n\r\nvoid cscrSetBackground(float col) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;    \r\n  *(cscrOffsets[cscrSelectedScreen]+BACKGROUND_COLOR) = col;\r\n}\r\n\r\nvoid cscrSetRotation(float rot) {\r\n  *(cscrOffsets[cscrSelectedScreen]+SCREEN_ROTATION) = rot;    \r\n}\r\n\r\nvoid cscrSetBrightness(float bright) {\r\n  *(cscrOffsets[cscrSelectedScreen]+SCREEN_BRIGHTNESS) = bright;\r\n}\r\n\r\nvoid cscrLoadImage(char* imgdata) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;  \r\n\r\n  preserve ESI,EDI;\r\n  ESI = imgdata;\r\n  EDI = cscrOffsets[cscrSelectedScreen];\r\n  mcopy 30*18*2;\r\n}\r\n\r\nvoid cscrPutLine(char* scrptr, float col, char* str) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;  \r\n  char* curptr = scrptr;\r\n\r\n  while (*str) {\r\n    *(cscrOffsets[cscrSelectedScreen]+curptr*2+0) = *str;\r\n    *(cscrOffsets[cscrSelectedScreen]+curptr*2+1) = col;\r\n\r\n    str++;\r\n    curptr++;\r\n  }\r\n}\r\n\r\nvoid cscrPutChar(char* scrptr, float col, char ch) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;  \r\n\r\n  *(cscrOffsets[cscrSelectedScreen]+scrptr*2+0) = ch;\r\n  *(cscrOffsets[cscrSelectedScreen]+scrptr*2+1) = col;\r\n}\r\n\r\nvoid cscrNewLine() {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n\r\n  cscrCharacterPointer[cscrSelectedScreen] /= 30;\r\n  fint cscrCharacterPointer[cscrSelectedScreen];\r\n  cscrCharacterPointer[cscrSelectedScreen] = (cscrCharacterPointer[cscrSelectedScreen]+1)*30;\r\n\r\n  if (cscrCharacterPointer[cscrSelectedScreen] >= 30*18) {\r\n    cscrCharacterPointer[cscrSelectedScreen] = cscrCharacterPointer[cscrSelectedScreen] - 30;\r\n    *(cscrOffsets[cscrSelectedScreen]+SHIFT_ROWS) = 1;\r\n  }\r\n}\r\n\r\nvoid cscrPrintLine(char* str, float col) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n\r\n  while (*str) {\r\n    if (*str == '\\n') {\r\n      cscrNewLine();\r\n      str++;\r\n      if (*str == 0) return;\r\n    }\r\n    \r\n    *(cscrOffsets[cscrSelectedScreen]+cscrCharacterPointer[cscrSelectedScreen]*2+0) = *str;\r\n    *(cscrOffsets[cscrSelectedScreen]+cscrCharacterPointer[cscrSelectedScreen]*2+1) = col;\r\n    \r\n    cscrCharacterPointer[cscrSelectedScreen]++;    \r\n    if (cscrCharacterPointer[cscrSelectedScreen] >= 30*18) cscrNewLine();       \r\n    str++;\r\n  }\r\n}\r\n\r\nvoid cscrPrintNumber(float num, float col) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;\r\n  \r\n  float ndig,a;\r\n  a = num;\r\n  ndig = 0;\r\n  while (a > 0) {\r\n    ndig++;\r\n    a /= 10;\r\n    fint a;  \r\n  }\r\n  max ndig,1;\r\n  a = num;\r\n\r\n  cscrCharacterPointer[cscrSelectedScreen] = cscrCharacterPointer[cscrSelectedScreen] + ndig;\r\n  char* charPtr = cscrCharacterPointer[cscrSelectedScreen] - 1;\r\n  while (ndig > 0) {\r\n    preserve EDX;\r\n    mov EDX,a;\r\n    mod EDX,10;\r\n    add EDX,48;\r\n    \r\n    *(cscrOffsets[cscrSelectedScreen]+charPtr*2+0) = EDX;\r\n    *(cscrOffsets[cscrSelectedScreen]+charPtr*2+1) = col;\r\n    charPtr--;\r\n \r\n    a /= 10;\r\n    fint a;\r\n    \r\n    ndig--;\r\n  }\r\n}\r\n\r\nvoid cscrSetCursor(float x, y) {\r\n  if (!cscrOffsets[cscrSelectedScreen]) return;  \r\n  cscrCharacterPointer[cscrSelectedScreen] = x+y*30;\r\n}"},"cpuchip/lib/zcrt/":{"cpuchip/lib/zcrt/string.txt":"//------------------------------------------------------------------------------\r\n// ZCPU CRT sourcecode (for HL-ZASM compiler)         (C) 2011 by Black Phoenix\r\n//\r\n// String library. Contains functions to work with C strings (C89-compatible)\r\n//------------------------------------------------------------------------------\r\n\r\n#define NULL 0\r\n\r\n//copies n bytes between two memory areas; if there is overlap, the behavior is undefined\r\nvoid *memcpy(void *dest, void *src, float n) {\r\n  preserve esi,edi;\r\n  register float rem;\r\n  \r\n  esi = src;\r\n  edi = dest;\r\n  rem = n;\r\n  while (rem) {\r\n    register float count = rem;\r\n    min count,8192;\r\n    mcopy count;\r\n    rem = rem - count;\r\n  }\r\n  return dest;\r\n}\r\n\r\n//copies n bytes between two memory areas; unlike with memcpy the areas may overlap\r\n//void *memmove(void *dest, void *src, float n);\r\n#define memmove memcpy\r\n\r\n//returns a pointer to the first occurrence of c in the first n bytes of s, or NULL if not found\r\nvoid* memchr(void *s, float c, float n) {\r\n  register void *r = s;\r\n  register float rem = n;\r\n\r\n  while (rem) {\r\n    if (*r == c) {\r\n      return r;\r\n    }\r\n    ++r;\r\n    --rem;\r\n  }\r\n\r\n  return NULL;\r\n}\r\n\r\n//compares the first n bytes of two memory areas\r\n//int memcmp(const void *s1, const void *s2, float n);\r\n#define memcmp strcmp\r\n\r\n//overwrites a memory area with n copies of c\r\nvoid* memset(void *ptr, float c, float n) {\r\n  register void *p = ptr;\r\n  register float rem = n;\r\n  register float ch = c;\r\n\r\n  while (rem) {\r\n    *p++ = ch;\r\n    --rem;\r\n  }\r\n\r\n  return ptr;\r\n}\r\n\r\n//appends the string src to dest\r\nchar* strcat(char *src, *dest) {\r\n  register char *srcptr, *destptr;\r\n  \r\n  srcptr = src;\r\n  while (*++srcptr) ;\r\n\r\n  destptr = dest;\r\n  while (*srcptr++ = *destptr++) ;\r\n  return src;\r\n}\r\n\r\n//appends at most n bytes of the string src to dest\r\nchar* strncat(char *src, *dest, float n) {\r\n  register char *srcptr, *destptr;\r\n  register float i;\r\n  \r\n  srcptr = src;\r\n  srcptr--;\r\n  while (*++srcptr) ;\r\n\r\n  destptr = dest;\r\n  i = n;\r\n  while (i--) {\r\n    if (*srcptr++ = *destptr++) continue;\r\n  }\r\n  *srcptr = 0;\r\n  return src;\r\n}\r\n\r\n//locates character c in a string, searching from the beginning\r\nchar* strchr(char *str, c) {\r\n  register char *strptr, ch;\r\n  strptr = str;\r\n  ch = c;\r\n  while(*strptr) {\r\n    if (*strptr == ch) return strptr;\r\n    ++strptr;\r\n  }\r\n  return 0;\r\n}\r\n\r\n//locates character c in a string, searching from the end\r\nchar* strrchr(char *str, c) {\r\n  register char *strptr, ch;\r\n  register char *findptr;\r\n  \r\n  findptr = 0;\r\n  strptr = str;\r\n  ch = c;\r\n  while (*strptr) {\r\n    if (*strptr == ch) findptr = strptr;\r\n    ++strptr;\r\n  }\r\n  return findptr;\r\n}\r\n\r\n//compares two strings lexicographically\r\nfloat strcmp(char *src, *dest) {\r\n  register char *srcptr, *destptr;\r\n\r\n  srcptr = src;\r\n  destptr = dest;\r\n  while (*srcptr == *destptr) {\r\n    if (*srcptr == 0) return 0;\r\n    ++srcptr; ++destptr;\r\n  }\r\n  return (*srcptr - *destptr);\r\n}\r\n\r\n//compares up to the first n bytes of two strings lexicographically\r\nfloat strncmp(char *src, *dest, float n) {\r\n  register char *srcptr, *destptr;\r\n  register float i;\r\n  \r\n  srcptr = src;\r\n  destptr = dest;\r\n  i = n;\r\n\r\n  while (i && (*srcptr == *destptr)) {\r\n    if (*srcptr == 0) return 0;\r\n    ++srcptr; ++destptr; --i;\r\n  }\r\n  if (i) return (*srcptr - *destptr);\r\n  return 0;\r\n}\r\n\r\n//copies a string from one location to another\r\nchar* strcpy(char *dest, *src) {\r\n  register char *srcptr, *destptr;\r\n\r\n  destptr = dest;\r\n  srcptr = src;\r\n  while (*destptr++ = *srcptr++) ;\r\n  return dest;\r\n}\r\n\r\n\r\n//write exactly n bytes to dest, copying from src or add 0's\r\nchar* strncpy(char *dest, *src, float n) {\r\n  register char *srcptr, *destptr;\r\n  register float i;\r\n\r\n  destptr = dest;\r\n  srcptr = src;\r\n  i = n;\r\n  \r\n  while (i-- > 0) {\r\n    if (*destptr++ = *srcptr++) continue;\r\n    while (i-- > 0) *destptr++ = 0;\r\n  }\r\n  *destptr = 0;\r\n  return dest;\r\n}\r\n\r\n//returns the string representation of an error number e.g. errno\r\n//char *strerror(int);\r\n\r\n//finds the length of a C string\r\nfloat strlen(char* str) {\r\n  register char* strptr;\r\n  register float n;\r\n  \r\n  strptr = str;\r\n  n = 0;\r\n  while (*strptr++) n++;\r\n  return n;\r\n}\r\n\r\n//determines the length of the maximal initial substring consisting entirely of characters in accept\r\nfloat strspn(char *str, *accept) {\r\n  register char *s = str;\r\n  register char *p = accept;\r\n\r\n  while (*p) {\r\n    if (*p++ == *s) {\r\n      ++s;\r\n      p = accept;\r\n    }\r\n  }\r\n  return s - str;\r\n}\r\n\r\n//determines the length of the maximal initial substring consisting entirely of characters not in reject\r\nfloat strcspn(char *str, char *reject) {\r\n  register char *s, *p;\r\n  \r\n  for (s=str; *s; s++) {\r\n    for (p=reject; *p; p++) {\r\n      if (*p == *s) goto done;\r\n    }\r\n  }\r\n  done:\r\n  return s - str;\r\n}\r\n\r\n//finds the first occurrence of any character in accept\r\nchar* strpbrk(char *str, char *accept) {\r\n  register char *s;\r\n  register char *p;\r\n\r\n  for (s=str; *s; s++) {\r\n    for (p=accept; *p; p++) {\r\n      if (*p == *s) return s;\r\n    }\r\n  }\r\n  return NULL;\r\n}\r\n\r\n//finds the first occurrence of the string \"needle\" in the longer string \"haystack\"\r\nchar *strstr(char *haystack, char *needle) {\r\n  register char *s = haystack;\r\n  register char *p = needle;\r\n\r\n  while (1) {\r\n    if (!*p) {\r\n      return haystack;\r\n    }\r\n    if (*p == *s) {\r\n      ++p;\r\n      ++s;\r\n    } else {\r\n      p = needle;\r\n      if (!*s) {\r\n        return NULL;\r\n      }\r\n      s = ++haystack;\r\n    }\r\n  }\r\n}\r\n\r\n//parses a string into a sequence of tokens; non-thread safe in the spec, non-reentrant\r\n//char *strtok(char *, const char * delim);\r\n\r\n//transforms src into a collating form, such that the numerical sort order of the transformed string is equivalent to the collating order of src\r\n//float strxfrm(char *dest, const char *src, float n);\r\n","cpuchip/lib/zcrt/ctype.txt":"//------------------------------------------------------------------------------\r\n// ZCPU CRT sourcecode (for HL-ZASM compiler)         (C) 2011 by Black Phoenix\r\n//\r\n// Character classification functions.\r\n//------------------------------------------------------------------------------\r\n\r\n#define _CONTROL 1\r\n#define _SPACE   2\r\n#define _BLANK   4\r\n#define _DIGIT   8\r\n#define _HEX     16\r\n#define _PUNCT   32\r\n#define _UPPER   64\r\n#define _LOWER   128\r\n#define _GRAPH   256\r\n\r\n#define _MAXCHARS 0x83\r\n\r\n//test for alphanumeric character\r\nfloat isalnum(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n  \r\n  band eax,_LOWER+_UPPER+_DIGIT;\r\n}\r\n\r\n//test for alphabetic character\r\nfloat isalpha(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_LOWER+_UPPER;\r\n}\r\n\r\n//test for blank character\r\nfloat isblank(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_BLANK;\r\n}\r\n\r\n//test for control character\r\nfloat iscontrol(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_CONTROL;\r\n}\r\n\r\n//test for digit\r\nfloat isdigit(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_DIGIT;\r\n}\r\n\r\n//test for graphic character, excluding the space character\r\nfloat isgraph(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_GRAPH;\r\n}\r\n\r\n//test for lowercase character\r\nfloat islower(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_LOWER;\r\n}\r\n\r\n//test for printable character, including the space character.\r\nfloat isprint(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_LOWER+_UPPER+_DIGIT+_PUNCT+_BLANK+_GRAPH;\r\n}\r\n\r\n//test for punctuation character\r\nfloat ispunct(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_PUNCT;\r\n}\r\n\r\n//test for any whitespace character\r\nfloat isspace(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_SPACE;\r\n}\r\n\r\n//test for uppercase character\r\nfloat isupper(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_UPPER;\r\n}\r\n\r\n//test for hexadecimal digit. Not locale-specific.\r\nfloat isxdigit(char c) {\r\n  preserve eax;\r\n  eax = c; max eax,0; min eax,_MAXCHARS;\r\n  eax = __ctype_characters[eax];\r\n\r\n  band eax,_HEX;\r\n}\r\n\r\n//convert character to lowercase\r\nchar tolower(char c) {\r\n  if (islower(c)) return c - 0x20;\r\n  return c;\r\n}\r\n\r\n//convert character to uppercase\r\nchar toupper(char c) {\r\n  if (isupper(c)) return c + 0x20;\r\n  return c;\r\n}\r\n\r\n__ctype_characters:\r\n  db _CONTROL,        //00 (NUL)\r\n  db _CONTROL;        //01 (SOH)\r\n  db _CONTROL;        //02 (STX)\r\n  db _CONTROL;        //03 (ETX)\r\n  db _CONTROL;        //04 (EOT)\r\n  db _CONTROL;        //05 (ENQ)\r\n  db _CONTROL;        //06 (ACK)\r\n  db _CONTROL;        //07 (BEL)\r\n  db _CONTROL;        //08 (BS)\r\n  db _SPACE+_CONTROL; //09 (HT)\r\n  db _SPACE+_CONTROL; //0A (LF)\r\n  db _SPACE+_CONTROL; //0B (VT)\r\n  db _SPACE+_CONTROL; //0C (FF)\r\n  db _SPACE+_CONTROL; //0D (CR)\r\n  db _CONTROL;        //0E (SI)\r\n  db _CONTROL;        //0F (SO)\r\n  db _CONTROL;        //10 (DLE)\r\n  db _CONTROL;        //11 (DC1)\r\n  db _CONTROL;        //12 (DC2)\r\n  db _CONTROL;        //13 (DC3)\r\n  db _CONTROL;        //14 (DC4)\r\n  db _CONTROL;        //15 (NAK)\r\n  db _CONTROL;        //16 (SYN)\r\n  db _CONTROL;        //17 (ETB)\r\n  db _CONTROL;        //18 (CAN)\r\n  db _CONTROL;        //19 (EM)\r\n  db _CONTROL;        //1A (SUB)\r\n  db _CONTROL;        //1B (ESC)\r\n  db _CONTROL;        //1C (FS)\r\n  db _CONTROL;        //1D (GS)\r\n  db _CONTROL;        //1E (RS)\r\n  db _CONTROL;        //1F (US)\r\n  db _SPACE+_BLANK;   //20 SPACE\r\n  db _PUNCT;          //21 !\r\n  db _PUNCT;          //22 \"\r\n  db _PUNCT;          //23 #\r\n  db _PUNCT;          //24 $\r\n  db _PUNCT;          //25 %\r\n  db _PUNCT;          //26 &\r\n  db _PUNCT;          //27 '\r\n  db _PUNCT;          //28 (\r\n  db _PUNCT;          //29 )\r\n  db _PUNCT;          //2A *\r\n  db _PUNCT;          //2B +\r\n  db _PUNCT;          //2C ;\r\n  db _PUNCT;          //2D -\r\n  db _PUNCT;          //2E .\r\n  db _PUNCT;          //2F /\r\n  db _DIGIT+_HEX;     //30 0\r\n  db _DIGIT+_HEX;     //31 1\r\n  db _DIGIT+_HEX;     //32 2\r\n  db _DIGIT+_HEX;     //33 3\r\n  db _DIGIT+_HEX;     //34 4\r\n  db _DIGIT+_HEX;     //35 5\r\n  db _DIGIT+_HEX;     //36 6\r\n  db _DIGIT+_HEX;     //37 7\r\n  db _DIGIT+_HEX;     //38 8\r\n  db _DIGIT+_HEX;     //39 9\r\n  db _PUNCT;          //3A :\r\n  db _PUNCT;          //3B ;\r\n  db _PUNCT;          //3C <\r\n  db _PUNCT;          //3D =\r\n  db _PUNCT;          //3E >\r\n  db _PUNCT;          //3F ?\r\n  db _PUNCT;          //40 @\r\n  db _UPPER+_HEX;     //41 A\r\n  db _UPPER+_HEX;     //42 B\r\n  db _UPPER+_HEX;     //43 C\r\n  db _UPPER+_HEX;     //44 D\r\n  db _UPPER+_HEX;     //45 E\r\n  db _UPPER+_HEX;     //46 F\r\n  db _UPPER;          //47 G\r\n  db _UPPER;          //48 H\r\n  db _UPPER;          //49 I\r\n  db _UPPER;          //4A J\r\n  db _UPPER;          //4B K\r\n  db _UPPER;          //4C L\r\n  db _UPPER;          //4D M\r\n  db _UPPER;          //4E N\r\n  db _UPPER;          //4F O\r\n  db _UPPER;          //50 P\r\n  db _UPPER;          //51 Q\r\n  db _UPPER;          //52 R\r\n  db _UPPER;          //53 S\r\n  db _UPPER;          //54 T\r\n  db _UPPER;          //55 U\r\n  db _UPPER;          //56 V\r\n  db _UPPER;          //57 W\r\n  db _UPPER;          //58 X\r\n  db _UPPER;          //59 Y\r\n  db _UPPER;          //5A Z\r\n  db _PUNCT;          //5B [\r\n  db _PUNCT;          //5C \\\r\n  db _PUNCT;          //5D ]\r\n  db _PUNCT;          //5E ^\r\n  db _PUNCT;          //5F _\r\n  db _PUNCT;          //60 `\r\n  db _LOWER+_HEX;     //61 a\r\n  db _LOWER+_HEX;     //62 b\r\n  db _LOWER+_HEX;     //63 c\r\n  db _LOWER+_HEX;     //64 d\r\n  db _LOWER+_HEX;     //65 e\r\n  db _LOWER+_HEX;     //66 f\r\n  db _LOWER;          //67 g\r\n  db _LOWER;          //68 h\r\n  db _LOWER;          //69 i\r\n  db _LOWER;          //6A j\r\n  db _LOWER;          //6B k\r\n  db _LOWER;          //6C l\r\n  db _LOWER;          //6D m\r\n  db _LOWER;          //6E n\r\n  db _LOWER;          //6F o\r\n  db _LOWER;          //70 p\r\n  db _LOWER;          //71 q\r\n  db _LOWER;          //72 r\r\n  db _LOWER;          //73 s\r\n  db _LOWER;          //74 t\r\n  db _LOWER;          //75 u\r\n  db _LOWER;          //76 v\r\n  db _LOWER;          //77 w\r\n  db _LOWER;          //78 x\r\n  db _LOWER;          //79 y\r\n  db _LOWER;          //7A z\r\n  db _PUNCT;          //7B {\r\n  db _PUNCT;          //7C |\r\n  db _PUNCT;          //7D }\r\n  db _PUNCT;          //7E ~\r\n  db _CONTROL;        //7F (DEL)\r\n  \r\n  db _GRAPH;          //80\r\n  db _GRAPH;          //81\r\n  db _GRAPH;          //82\r\n  db _GRAPH;          //83","cpuchip/lib/zcrt/init.txt":"//------------------------------------------------------------------------------\r\n// ZCPU CRT sourcecode (for HL-ZASM compiler)         (C) 2011 by Black Phoenix\r\n//\r\n// C runtime library initialization\r\n//------------------------------------------------------------------------------\r\n\r\n#ifdef ZCRT_EXTENDED_MODE\r\n  // Initialize extended mode\r\n  mov edi,&zcrtInterruptTable; //Need \"&\" because array is defined below\r\n  mov esi,&zcrtInterruptTable; add esi,1024;\r\n  @InitTable:\r\n    mov #edi,zcrtErrorHandler; inc edi;\r\n    mov #edi,0;                inc edi;\r\n    mov #edi,0;                inc edi;\r\n    mov #edi,32;               inc edi;\r\n    cmp edi,esi;\r\n    jl @InitTable;\r\n\r\n  lidtr zcrtInterruptTable;\r\n  stef;\r\n#endif\r\n\r\n// Call main function\r\nmain();\r\n\r\n// Stop the processor execution\r\n#ifdef ZCRT_EXTENDED_MODE\r\n  clef;\r\n#endif\r\nint 1;\r\n\r\n//------------------------------------------------------------------------------\r\n// Allocate the interrupt table\r\n#ifdef ZCRT_EXTENDED_MODE\r\n  float zcrtInterruptTable[1024];\r\n  char* zcrtInterruptEntrypoint;\r\n  \r\n  // Default interrupt handlers\r\n  zcrtErrorHandler:\r\n    //Execute handler if required\r\n    if (zcrtInterruptEntrypoint) {\r\n      float errorNo,errorCode;\r\n      cpuget errorNo,28;\r\n      cpuget errorCode,27;\r\n\r\n      zcrtInterruptEntrypoint(errorNo,errorCode);\r\n    }\r\n  iret\r\n#endif\r\n"}},"cpuchip/programs/":[]}}
